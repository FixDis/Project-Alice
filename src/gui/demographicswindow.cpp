namespace alice_ui {
struct demographicswindow_main_close_button_t;
struct demographicswindow_main_title_t;
struct demographicswindow_main_main_page_t;
struct demographicswindow_main_table_t;
struct demographicswindow_main_show_filters_t;
struct demographicswindow_main_reset_filters_t;
struct demographicswindow_main_only_pops_toggle_t;
struct demographicswindow_main_main_left_t;
struct demographicswindow_main_main_right_t;
struct demographicswindow_main_t;
struct demographicswindow_nation_row_location_t;
struct demographicswindow_nation_row_size_t;
struct demographicswindow_nation_row_size_trend_t;
struct demographicswindow_nation_row_culture_t;
struct demographicswindow_nation_row_job_t;
struct demographicswindow_nation_row_religion_t;
struct demographicswindow_nation_row_ideology_t;
struct demographicswindow_nation_row_issues_t;
struct demographicswindow_nation_row_militancy_t;
struct demographicswindow_nation_row_consciousness_t;
struct demographicswindow_nation_row_employment_t;
struct demographicswindow_nation_row_literacy_t;
struct demographicswindow_nation_row_money_t;
struct demographicswindow_nation_row_needs_t;
struct demographicswindow_nation_row_frames_t;
struct demographicswindow_nation_row_t;
struct demographicswindow_state_row_folder_icon_t;
struct demographicswindow_state_row_location_t;
struct demographicswindow_state_row_size_t;
struct demographicswindow_state_row_size_trend_t;
struct demographicswindow_state_row_culture_t;
struct demographicswindow_state_row_job_t;
struct demographicswindow_state_row_religion_t;
struct demographicswindow_state_row_ideology_t;
struct demographicswindow_state_row_issues_t;
struct demographicswindow_state_row_militancy_t;
struct demographicswindow_state_row_consciousness_t;
struct demographicswindow_state_row_employment_t;
struct demographicswindow_state_row_literacy_t;
struct demographicswindow_state_row_money_t;
struct demographicswindow_state_row_needs_t;
struct demographicswindow_state_row_frames_t;
struct demographicswindow_state_row_focus_button_t;
struct demographicswindow_state_row_t;
struct demographicswindow_province_row_folder_icon_t;
struct demographicswindow_province_row_location_t;
struct demographicswindow_province_row_size_t;
struct demographicswindow_province_row_size_trend_t;
struct demographicswindow_province_row_culture_t;
struct demographicswindow_province_row_job_t;
struct demographicswindow_province_row_religion_t;
struct demographicswindow_province_row_ideology_t;
struct demographicswindow_province_row_issues_t;
struct demographicswindow_province_row_militancy_t;
struct demographicswindow_province_row_consciousness_t;
struct demographicswindow_province_row_employment_t;
struct demographicswindow_province_row_literacy_t;
struct demographicswindow_province_row_money_t;
struct demographicswindow_province_row_needs_t;
struct demographicswindow_province_row_frames_t;
struct demographicswindow_province_row_t;
struct demographicswindow_pop_row_location_t;
struct demographicswindow_pop_row_size_t;
struct demographicswindow_pop_row_size_trend_t;
struct demographicswindow_pop_row_culture_t;
struct demographicswindow_pop_row_job_t;
struct demographicswindow_pop_row_religion_t;
struct demographicswindow_pop_row_ideology_t;
struct demographicswindow_pop_row_issues_t;
struct demographicswindow_pop_row_militancy_t;
struct demographicswindow_pop_row_consciousness_t;
struct demographicswindow_pop_row_employment_t;
struct demographicswindow_pop_row_literacy_t;
struct demographicswindow_pop_row_money_t;
struct demographicswindow_pop_row_needs_t;
struct demographicswindow_pop_row_rebel_flag_t;
struct demographicswindow_pop_row_culture_name_t;
struct demographicswindow_pop_row_job_name_t;
struct demographicswindow_pop_row_religion_name_t;
struct demographicswindow_pop_row_frames_t;
struct demographicswindow_pop_row_movement_political_t;
struct demographicswindow_pop_row_movement_social_t;
struct demographicswindow_pop_row_details_button_t;
struct demographicswindow_pop_row_t;
struct demographicswindow_filters_window_job_all_t;
struct demographicswindow_filters_window_job_none_t;
struct demographicswindow_filters_window_culture_all_t;
struct demographicswindow_filters_window_culture_none_t;
struct demographicswindow_filters_window_religion_all_t;
struct demographicswindow_filters_window_religion_none_t;
struct demographicswindow_filters_window_location_all_t;
struct demographicswindow_filters_window_location_none_t;
struct demographicswindow_filters_window_non_colonial_t;
struct demographicswindow_filters_window_colonial_t;
struct demographicswindow_filters_window_job_list_t;
struct demographicswindow_filters_window_culture_list_t;
struct demographicswindow_filters_window_religion_list_t;
struct demographicswindow_filters_window_location_list_t;
struct demographicswindow_filters_window_close_button_t;
struct demographicswindow_filters_window_job_left_t;
struct demographicswindow_filters_window_culture_left_t;
struct demographicswindow_filters_window_religion_left_t;
struct demographicswindow_filters_window_location_left_t;
struct demographicswindow_filters_window_job_right_t;
struct demographicswindow_filters_window_culture_right_t;
struct demographicswindow_filters_window_religion_right_t;
struct demographicswindow_filters_window_location_right_t;
struct demographicswindow_filters_window_job_page_t;
struct demographicswindow_filters_window_culture_page_t;
struct demographicswindow_filters_window_religion_page_t;
struct demographicswindow_filters_window_location_page_t;
struct demographicswindow_filters_window_job_header_t;
struct demographicswindow_filters_window_culture_header_t;
struct demographicswindow_filters_window_religion_header_t;
struct demographicswindow_filters_window_location_header_t;
struct demographicswindow_filters_window_t;
struct demographicswindow_job_filter_filter_button_t;
struct demographicswindow_job_filter_icon_t;
struct demographicswindow_job_filter_filter_label_t;
struct demographicswindow_job_filter_t;
struct demographicswindow_religion_filter_filter_button_t;
struct demographicswindow_religion_filter_icon_t;
struct demographicswindow_religion_filter_filter_label_t;
struct demographicswindow_religion_filter_t;
struct demographicswindow_location_filter_filter_button_t;
struct demographicswindow_location_filter_filter_label_t;
struct demographicswindow_location_filter_t;
struct demographicswindow_culture_filter_filter_button_t;
struct demographicswindow_culture_filter_filter_label_t;
struct demographicswindow_culture_filter_t;
struct demographicswindow_main_close_button_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	dcon::text_key tooltip_key;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_key_down(sys::state& state, sys::virtual_key key, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_title_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 2.000000f; 
	bool text_is_header = true; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_main_page_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_table_header_t : public ui::element_base {
	inline static int16_t spacer_column_start = 0;
	inline static int16_t spacer_column_width = 0;
	text::layout location_internal_layout;
	inline static text::text_color  location_text_color = text::text_color::black;
	std::string location_cached_text;
	inline static dcon::text_key location_text_key;
	inline static int16_t location_column_start = 0;
	inline static int16_t location_column_width = 0;
	text::layout size_internal_layout;
	inline static text::text_color  size_text_color = text::text_color::black;
	std::string size_cached_text;
	inline static dcon::text_key size_text_key;
	inline static int8_t size_sort_direction = 0;
	inline static int16_t size_column_start = 0;
	inline static int16_t size_column_width = 0;
	text::layout culture_internal_layout;
	inline static text::text_color  culture_text_color = text::text_color::black;
	std::string culture_cached_text;
	inline static dcon::text_key culture_text_key;
	inline static int8_t culture_sort_direction = 0;
	inline static int16_t culture_column_start = 0;
	inline static int16_t culture_column_width = 0;
	text::layout job_internal_layout;
	inline static text::text_color  job_text_color = text::text_color::black;
	std::string job_cached_text;
	inline static dcon::text_key job_text_key;
	inline static int8_t job_sort_direction = 0;
	inline static int16_t job_column_start = 0;
	inline static int16_t job_column_width = 0;
	text::layout religion_internal_layout;
	inline static text::text_color  religion_text_color = text::text_color::black;
	std::string religion_cached_text;
	inline static dcon::text_key religion_text_key;
	inline static int8_t religion_sort_direction = 0;
	inline static int16_t religion_column_start = 0;
	inline static int16_t religion_column_width = 0;
	text::layout ideology_internal_layout;
	inline static text::text_color  ideology_text_color = text::text_color::black;
	std::string ideology_cached_text;
	inline static dcon::text_key ideology_text_key;
	inline static int16_t ideology_column_start = 0;
	inline static int16_t ideology_column_width = 0;
	text::layout issues_internal_layout;
	inline static text::text_color  issues_text_color = text::text_color::black;
	std::string issues_cached_text;
	inline static dcon::text_key issues_text_key;
	inline static int16_t issues_column_start = 0;
	inline static int16_t issues_column_width = 0;
	text::layout militancy_internal_layout;
	inline static text::text_color  militancy_text_color = text::text_color::black;
	std::string militancy_cached_text;
	inline static dcon::text_key militancy_text_key;
	inline static int8_t militancy_sort_direction = 0;
	inline static int16_t militancy_column_start = 0;
	inline static int16_t militancy_column_width = 0;
	text::layout consciousness_internal_layout;
	inline static text::text_color  consciousness_text_color = text::text_color::black;
	std::string consciousness_cached_text;
	inline static dcon::text_key consciousness_text_key;
	inline static int8_t consciousness_sort_direction = 0;
	inline static int16_t consciousness_column_start = 0;
	inline static int16_t consciousness_column_width = 0;
	text::layout employment_internal_layout;
	inline static text::text_color  employment_text_color = text::text_color::black;
	std::string employment_cached_text;
	inline static dcon::text_key employment_text_key;
	inline static int8_t employment_sort_direction = 0;
	inline static int16_t employment_column_start = 0;
	inline static int16_t employment_column_width = 0;
	text::layout literacy_internal_layout;
	inline static text::text_color  literacy_text_color = text::text_color::black;
	std::string literacy_cached_text;
	inline static dcon::text_key literacy_text_key;
	inline static int8_t literacy_sort_direction = 0;
	inline static int16_t literacy_column_start = 0;
	inline static int16_t literacy_column_width = 0;
	text::layout money_internal_layout;
	inline static text::text_color  money_text_color = text::text_color::black;
	std::string money_cached_text;
	inline static dcon::text_key money_text_key;
	inline static int8_t money_sort_direction = 0;
	inline static int16_t money_column_start = 0;
	inline static int16_t money_column_width = 0;
	text::layout needs_internal_layout;
	inline static text::text_color  needs_text_color = text::text_color::black;
	std::string needs_cached_text;
	inline static dcon::text_key needs_text_key;
	inline static int8_t needs_sort_direction = 0;
	inline static int16_t needs_column_start = 0;
	inline static int16_t needs_column_width = 0;
	text::layout rebels_internal_layout;
	inline static text::text_color  rebels_text_color = text::text_color::black;
	std::string rebels_cached_text;
	inline static dcon::text_key rebels_text_key;
	inline static int16_t rebels_column_start = 0;
	inline static int16_t rebels_column_width = 0;
	inline static std::string_view ascending_icon_key;
	inline static dcon::texture_id ascending_icon;
	inline static std::string_view descending_icon_key;
	inline static dcon::texture_id descending_icon;
	void on_reset_text(sys::state & state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void tooltip_position(sys::state& state, int32_t x, int32_t y, int32_t& ident, ui::urect& subrect) noexcept override;
	void on_create(sys::state& state) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
};
struct demographicswindow_main_table_row_t : public ui::element_base {
	dcon::pop_id value;
	bool alternate_row = false;
	text::layout location_internal_layout;
	inline static text::text_color  location_default_text_color = text::text_color::black;
	text::text_color  location_text_color = location_default_text_color ;
	std::string location_cached_text;
	inline static text::alignment location_text_alignment = text::alignment::right;
	void set_location_text(sys::state & state, std::string const& new_text);
	text::layout size_internal_layout;
	inline static text::text_color  size_default_text_color = text::text_color::black;
	text::text_color  size_text_color = size_default_text_color ;
	std::string size_cached_text;
	inline static text::alignment size_text_alignment = text::alignment::center;
	void set_size_text(sys::state & state, std::string const& new_text);
	text::layout culture_internal_layout;
	inline static text::text_color  culture_default_text_color = text::text_color::black;
	text::text_color  culture_text_color = culture_default_text_color ;
	std::string culture_cached_text;
	inline static text::alignment culture_text_alignment = text::alignment::center;
	void set_culture_text(sys::state & state, std::string const& new_text);
	text::layout job_internal_layout;
	inline static text::text_color  job_default_text_color = text::text_color::black;
	text::text_color  job_text_color = job_default_text_color ;
	std::string job_cached_text;
	inline static text::alignment job_text_alignment = text::alignment::center;
	void set_job_text(sys::state & state, std::string const& new_text);
	text::layout religion_internal_layout;
	inline static text::text_color  religion_default_text_color = text::text_color::black;
	text::text_color  religion_text_color = religion_default_text_color ;
	std::string religion_cached_text;
	inline static text::alignment religion_text_alignment = text::alignment::center;
	void set_religion_text(sys::state & state, std::string const& new_text);
	text::layout ideology_internal_layout;
	inline static text::text_color  ideology_default_text_color = text::text_color::black;
	text::text_color  ideology_text_color = ideology_default_text_color ;
	std::string ideology_cached_text;
	inline static text::alignment ideology_text_alignment = text::alignment::center;
	void set_ideology_text(sys::state & state, std::string const& new_text);
	text::layout issues_internal_layout;
	inline static text::text_color  issues_default_text_color = text::text_color::black;
	text::text_color  issues_text_color = issues_default_text_color ;
	std::string issues_cached_text;
	inline static text::alignment issues_text_alignment = text::alignment::center;
	void set_issues_text(sys::state & state, std::string const& new_text);
	text::layout militancy_internal_layout;
	inline static text::text_color  militancy_default_text_color = text::text_color::black;
	text::text_color  militancy_text_color = militancy_default_text_color ;
	std::string militancy_cached_text;
	inline static text::alignment militancy_text_alignment = text::alignment::center;
	void set_militancy_text(sys::state & state, std::string const& new_text);
	text::layout consciousness_internal_layout;
	inline static text::text_color  consciousness_default_text_color = text::text_color::black;
	text::text_color  consciousness_text_color = consciousness_default_text_color ;
	std::string consciousness_cached_text;
	inline static text::alignment consciousness_text_alignment = text::alignment::center;
	void set_consciousness_text(sys::state & state, std::string const& new_text);
	text::layout employment_internal_layout;
	inline static text::text_color  employment_default_text_color = text::text_color::black;
	text::text_color  employment_text_color = employment_default_text_color ;
	std::string employment_cached_text;
	inline static text::alignment employment_text_alignment = text::alignment::center;
	void set_employment_text(sys::state & state, std::string const& new_text);
	text::layout literacy_internal_layout;
	inline static text::text_color  literacy_default_text_color = text::text_color::black;
	text::text_color  literacy_text_color = literacy_default_text_color ;
	std::string literacy_cached_text;
	inline static text::alignment literacy_text_alignment = text::alignment::center;
	void set_literacy_text(sys::state & state, std::string const& new_text);
	text::layout money_internal_layout;
	inline static text::text_color  money_default_text_color = text::text_color::black;
	text::text_color  money_text_color = money_default_text_color ;
	std::string money_cached_text;
	inline static text::alignment money_text_alignment = text::alignment::center;
	void set_money_text(sys::state & state, std::string const& new_text);
	text::layout needs_internal_layout;
	inline static text::text_color  needs_default_text_color = text::text_color::black;
	text::text_color  needs_text_color = needs_default_text_color ;
	std::string needs_cached_text;
	inline static text::alignment needs_text_alignment = text::alignment::center;
	void set_needs_text(sys::state & state, std::string const& new_text);
	text::layout rebels_internal_layout;
	inline static text::text_color  rebels_default_text_color = text::text_color::black;
	text::text_color  rebels_text_color = rebels_default_text_color ;
	std::string rebels_cached_text;
	inline static text::alignment rebels_text_alignment = text::alignment::center;
	void set_rebels_text(sys::state & state, std::string const& new_text);
	inline static std::string_view row_texture_key;
	inline static dcon::texture_id row_background_texture;
	inline static std::string_view alt_row_texture_key;
	inline static dcon::texture_id alt_row_background_texture;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void tooltip_position(sys::state& state, int32_t x, int32_t y, int32_t& ident, ui::urect& subrect) noexcept override;
	void on_create(sys::state& state) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
};
struct demographicswindow_main_table_t : public ui::non_owning_container_base {
	struct nation_row_option { dcon::nation_id content; };
	std::vector<std::unique_ptr<ui::element_base>> nation_row_pool;
	struct state_row_option { dcon::state_instance_id content; };
	std::vector<std::unique_ptr<ui::element_base>> state_row_pool;
	struct province_row_option { dcon::province_id content; };
	std::vector<std::unique_ptr<ui::element_base>> province_row_pool;
	struct pop_row_option { dcon::pop_id value; };
	std::vector<std::unique_ptr<ui::element_base>> pop_row_pool;
	std::vector<std::unique_ptr<demographicswindow_main_table_row_t>> row_pool;
	std::vector<std::unique_ptr<demographicswindow_main_table_header_t>> header_pool;
	struct value_option { dcon::pop_id value; };
	int32_t page = 0;
	inline static float row_height = 0;
	inline static ogl::color4f table_highlight_color{float(1.000000), float(1.000000), float(1.000000), float(0.294118)};
	inline static ogl::color3f table_divider_color{float(0.000000), float(0.000000), float(0.000000)};
	std::vector<std::variant<std::monostate, value_option, nation_row_option, state_row_option, province_row_option, pop_row_option>> values;
	std::vector<int32_t> page_starts;
	bool open_page = false;
	int16_t layout_space = 0;
	void on_create(sys::state& state) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::consumed;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_scroll(sys::state & state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept override; 
	void change_page(sys::state & state, int32_t new_page); 
	int32_t max_page(); 
	void clear_table(); 
	void impl_change_page(sys::state & state, int32_t new_page); 
	void add_value(dcon::pop_id const& v); 
	void add_insert_nation_row(sys::state& state, dcon::nation_id const& content); 
	void add_insert_state_row(sys::state& state, dcon::state_instance_id const& content); 
	void add_insert_province_row(sys::state& state, dcon::province_id const& content); 
	void add_insert_pop_row(sys::state& state, dcon::pop_id const& value); 
	std::unique_ptr<demographicswindow_main_table_row_t> make_row(sys::state& state);
	std::unique_ptr<demographicswindow_main_table_header_t> make_headers(sys::state& state);
	void apply_sort(sys::state& state); 
	void impl_apply_sort(sys::state& state); 
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_show_filters_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_reset_filters_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_only_pops_toggle_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_main_left_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_main_right_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_location_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::left;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_size_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_size_trend_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_culture_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::culture_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_job_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::pop_type_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_religion_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::religion_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_ideology_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::ideology_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_issues_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::issue_option_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_militancy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_consciousness_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_employment_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_literacy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_money_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_needs_t : public ui::element_base {
	ogl::data_texture data_texture{ 99, 3 };
	struct graph_entry {int key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_nation_row_frames_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_folder_icon_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_location_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::left;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_size_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_size_trend_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_culture_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::culture_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_job_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::pop_type_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_religion_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::religion_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_ideology_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::ideology_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_issues_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::issue_option_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_militancy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_consciousness_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_employment_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_literacy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_money_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_needs_t : public ui::element_base {
	ogl::data_texture data_texture{ 99, 3 };
	struct graph_entry {int key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_frames_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_state_row_focus_button_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	bool disabled = false;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_folder_icon_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_location_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::left;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_size_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_size_trend_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_culture_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::culture_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_job_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::pop_type_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_religion_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::religion_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_ideology_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::ideology_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_issues_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::issue_option_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_militancy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_consciousness_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_employment_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_literacy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_money_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_needs_t : public ui::element_base {
	ogl::data_texture data_texture{ 99, 3 };
	struct graph_entry {int key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_province_row_frames_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_location_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::left;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_size_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_size_trend_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_culture_t : public ui::element_base {
	ogl::color4f color{ 1.000000f, 0.996078f, 1.000000f, 1.000000f };
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_job_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_religion_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_ideology_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::ideology_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_issues_t : public ui::element_base {
	ogl::data_texture data_texture{ 100, 3 };
	struct graph_entry {dcon::issue_option_id key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_militancy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_consciousness_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_employment_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_literacy_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_money_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::right;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_needs_t : public ui::element_base {
	ogl::data_texture data_texture{ 99, 3 };
	struct graph_entry {int key; ogl::color3f color; float amount; };
	std::vector<graph_entry> graph_content;
	void update_chart(sys::state& state);
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::position_sensitive_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_rebel_flag_t : public ui::element_base {
	std::variant<std::monostate, dcon::national_identity_id, dcon::rebel_faction_id, dcon::nation_id> flag;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_culture_name_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::left;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_job_name_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::left;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_religion_name_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::left;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_frames_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_movement_political_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_movement_social_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::variable_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_pop_row_details_button_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	dcon::text_key tooltip_key;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_job_all_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_job_none_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_culture_all_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_culture_none_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_religion_all_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_religion_none_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_location_all_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_location_none_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_non_colonial_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_colonial_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_job_list_t : public ui::container_base {
	int32_t page = 0;
	std::vector<dcon::pop_type_id> values;
	std::vector<ui::element_base*> visible_items;
	void on_create(sys::state& state) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return (values.size() > visible_items.size()) ? ui::message_result::consumed : ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_scroll(sys::state & state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept override; 
	void change_page(sys::state & state, int32_t new_page); 
	int32_t max_page(); 
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_culture_list_t : public ui::container_base {
	int32_t page = 0;
	std::vector<dcon::culture_id> values;
	std::vector<ui::element_base*> visible_items;
	void on_create(sys::state& state) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return (values.size() > visible_items.size()) ? ui::message_result::consumed : ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_scroll(sys::state & state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept override; 
	void change_page(sys::state & state, int32_t new_page); 
	int32_t max_page(); 
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_religion_list_t : public ui::container_base {
	int32_t page = 0;
	std::vector<dcon::religion_id> values;
	std::vector<ui::element_base*> visible_items;
	void on_create(sys::state& state) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return (values.size() > visible_items.size()) ? ui::message_result::consumed : ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_scroll(sys::state & state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept override; 
	void change_page(sys::state & state, int32_t new_page); 
	int32_t max_page(); 
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_location_list_t : public ui::container_base {
	int32_t page = 0;
	std::vector<dcon::state_instance_id> values;
	std::vector<ui::element_base*> visible_items;
	void on_create(sys::state& state) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return (values.size() > visible_items.size()) ? ui::message_result::consumed : ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_scroll(sys::state & state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept override; 
	void change_page(sys::state & state, int32_t new_page); 
	int32_t max_page(); 
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_close_button_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	dcon::text_key tooltip_key;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_key_down(sys::state& state, sys::virtual_key key, sys::key_modifiers mods) noexcept override;
	void update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_job_left_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_culture_left_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_religion_left_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_location_left_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_job_right_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_culture_right_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_religion_right_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_location_right_t : public ui::element_base {
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_job_page_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_culture_page_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_religion_page_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_location_page_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_job_header_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.250000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_culture_header_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.250000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_religion_header_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.250000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_filters_window_location_header_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::gold;
	float text_scale = 1.250000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	dcon::text_key text_key;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_job_filter_filter_button_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_job_filter_icon_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_job_filter_filter_label_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_religion_filter_filter_button_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_religion_filter_icon_t : public ui::element_base {
	std::string_view gfx_key;
	dcon::gfx_object_id background_gid;
	int32_t frame = 0;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_religion_filter_filter_label_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_location_filter_filter_button_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_location_filter_filter_label_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_culture_filter_filter_button_t : public ui::element_base {
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::consumed;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_culture_filter_filter_label_t : public ui::element_base {
	text::layout internal_layout;
	text::text_color text_color = text::text_color::black;
	float text_scale = 1.000000f; 
	bool text_is_header = false; 
	text::alignment text_alignment = text::alignment::center;
	std::string cached_text;
	void set_text(sys::state & state, std::string const& new_text);
	void on_reset_text(sys::state & state) noexcept override;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::tooltip_behavior has_tooltip(sys::state & state) noexcept override {
		return ui::tooltip_behavior::no_tooltip;
	}
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		if(type == ui::mouse_probe_type::click) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::tooltip) {
			return ui::message_result::unseen;
		} else if(type == ui::mouse_probe_type::scroll) {
			return ui::message_result::unseen;
		} else {
			return ui::message_result::unseen;
		}
	}
	void on_update(sys::state& state) noexcept override;
};
struct demographicswindow_main_t : public ui::container_base {
	demographicswindow_filters_window_t* filter_w;
	ui::pop_details_window* details_w;
	ui::national_focus_window* focus_w;
	demographicswindow_main_close_button_t* close_button = nullptr;
	demographicswindow_main_title_t* title = nullptr;
	demographicswindow_main_main_page_t* main_page = nullptr;
	demographicswindow_main_table_t* table = nullptr;
	demographicswindow_main_show_filters_t* show_filters = nullptr;
	demographicswindow_main_reset_filters_t* reset_filters = nullptr;
	demographicswindow_main_only_pops_toggle_t* only_pops_toggle = nullptr;
	demographicswindow_main_main_left_t* main_left = nullptr;
	demographicswindow_main_main_right_t* main_right = nullptr;
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return (type == ui::mouse_probe_type::scroll ? ui::message_result::unseen : ui::message_result::consumed);
	}
	void on_drag(sys::state& state, int32_t oldx, int32_t oldy, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override {
		auto location_abs = get_absolute_location(state, *this);
		if(location_abs.x <= oldx && oldx < base_data.size.x + location_abs.x && location_abs.y <= oldy && oldy < base_data.size.y + location_abs.y) {
			ui::xy_pair new_abs_pos = location_abs;
			new_abs_pos.x += int16_t(x - oldx);
			new_abs_pos.y += int16_t(y - oldy);
			if(ui::ui_width(state) > base_data.size.x)
				new_abs_pos.x = int16_t(std::clamp(int32_t(new_abs_pos.x), 0, ui::ui_width(state) - base_data.size.x));
			if(ui::ui_height(state) > base_data.size.y)
				new_abs_pos.y = int16_t(std::clamp(int32_t(new_abs_pos.y), 0, ui::ui_height(state) - base_data.size.y));
			if(state.world.locale_get_native_rtl(state.font_collection.get_current_locale())) {
				base_data.position.x -= int16_t(new_abs_pos.x - location_abs.x);
			} else {
				base_data.position.x += int16_t(new_abs_pos.x - location_abs.x);
			}
		base_data.position.y += int16_t(new_abs_pos.y - location_abs.y);
		}
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "filter_w") {
			return (void*)(&filter_w);
		}
		if(name == "details_w") {
			return (void*)(&details_w);
		}
		if(name == "focus_w") {
			return (void*)(&focus_w);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_main(sys::state& state);
struct demographicswindow_nation_row_t : public ui::container_base {
	dcon::nation_id content;
	demographicswindow_nation_row_location_t* location = nullptr;
	demographicswindow_nation_row_size_t* size = nullptr;
	demographicswindow_nation_row_size_trend_t* size_trend = nullptr;
	demographicswindow_nation_row_culture_t* culture = nullptr;
	demographicswindow_nation_row_job_t* job = nullptr;
	demographicswindow_nation_row_religion_t* religion = nullptr;
	demographicswindow_nation_row_ideology_t* ideology = nullptr;
	demographicswindow_nation_row_issues_t* issues = nullptr;
	demographicswindow_nation_row_militancy_t* militancy = nullptr;
	demographicswindow_nation_row_consciousness_t* consciousness = nullptr;
	demographicswindow_nation_row_employment_t* employment = nullptr;
	demographicswindow_nation_row_literacy_t* literacy = nullptr;
	demographicswindow_nation_row_money_t* money = nullptr;
	demographicswindow_nation_row_needs_t* needs = nullptr;
	demographicswindow_nation_row_frames_t* frames = nullptr;
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return (type == ui::mouse_probe_type::scroll ? ui::message_result::unseen : ui::message_result::consumed);
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "content") {
			return (void*)(&content);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_nation_row(sys::state& state);
struct demographicswindow_state_row_t : public ui::container_base {
	dcon::state_instance_id content;
	demographicswindow_state_row_folder_icon_t* folder_icon = nullptr;
	demographicswindow_state_row_location_t* location = nullptr;
	demographicswindow_state_row_size_t* size = nullptr;
	demographicswindow_state_row_size_trend_t* size_trend = nullptr;
	demographicswindow_state_row_culture_t* culture = nullptr;
	demographicswindow_state_row_job_t* job = nullptr;
	demographicswindow_state_row_religion_t* religion = nullptr;
	demographicswindow_state_row_ideology_t* ideology = nullptr;
	demographicswindow_state_row_issues_t* issues = nullptr;
	demographicswindow_state_row_militancy_t* militancy = nullptr;
	demographicswindow_state_row_consciousness_t* consciousness = nullptr;
	demographicswindow_state_row_employment_t* employment = nullptr;
	demographicswindow_state_row_literacy_t* literacy = nullptr;
	demographicswindow_state_row_money_t* money = nullptr;
	demographicswindow_state_row_needs_t* needs = nullptr;
	demographicswindow_state_row_frames_t* frames = nullptr;
	demographicswindow_state_row_focus_button_t* focus_button = nullptr;
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return (type == ui::mouse_probe_type::scroll ? ui::message_result::unseen : ui::message_result::consumed);
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "content") {
			return (void*)(&content);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_state_row(sys::state& state);
struct demographicswindow_province_row_t : public ui::container_base {
	dcon::province_id content;
	demographicswindow_province_row_folder_icon_t* folder_icon = nullptr;
	demographicswindow_province_row_location_t* location = nullptr;
	demographicswindow_province_row_size_t* size = nullptr;
	demographicswindow_province_row_size_trend_t* size_trend = nullptr;
	demographicswindow_province_row_culture_t* culture = nullptr;
	demographicswindow_province_row_job_t* job = nullptr;
	demographicswindow_province_row_religion_t* religion = nullptr;
	demographicswindow_province_row_ideology_t* ideology = nullptr;
	demographicswindow_province_row_issues_t* issues = nullptr;
	demographicswindow_province_row_militancy_t* militancy = nullptr;
	demographicswindow_province_row_consciousness_t* consciousness = nullptr;
	demographicswindow_province_row_employment_t* employment = nullptr;
	demographicswindow_province_row_literacy_t* literacy = nullptr;
	demographicswindow_province_row_money_t* money = nullptr;
	demographicswindow_province_row_needs_t* needs = nullptr;
	demographicswindow_province_row_frames_t* frames = nullptr;
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return (type == ui::mouse_probe_type::scroll ? ui::message_result::unseen : ui::message_result::consumed);
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "content") {
			return (void*)(&content);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_province_row(sys::state& state);
struct demographicswindow_pop_row_t : public ui::container_base {
	dcon::pop_id value;
	demographicswindow_pop_row_location_t* location = nullptr;
	demographicswindow_pop_row_size_t* size = nullptr;
	demographicswindow_pop_row_size_trend_t* size_trend = nullptr;
	demographicswindow_pop_row_culture_t* culture = nullptr;
	demographicswindow_pop_row_job_t* job = nullptr;
	demographicswindow_pop_row_religion_t* religion = nullptr;
	demographicswindow_pop_row_ideology_t* ideology = nullptr;
	demographicswindow_pop_row_issues_t* issues = nullptr;
	demographicswindow_pop_row_militancy_t* militancy = nullptr;
	demographicswindow_pop_row_consciousness_t* consciousness = nullptr;
	demographicswindow_pop_row_employment_t* employment = nullptr;
	demographicswindow_pop_row_literacy_t* literacy = nullptr;
	demographicswindow_pop_row_money_t* money = nullptr;
	demographicswindow_pop_row_needs_t* needs = nullptr;
	demographicswindow_pop_row_rebel_flag_t* rebel_flag = nullptr;
	demographicswindow_pop_row_culture_name_t* culture_name = nullptr;
	demographicswindow_pop_row_job_name_t* job_name = nullptr;
	demographicswindow_pop_row_religion_name_t* religion_name = nullptr;
	demographicswindow_pop_row_frames_t* frames = nullptr;
	demographicswindow_pop_row_movement_political_t* movement_political = nullptr;
	demographicswindow_pop_row_movement_social_t* movement_social = nullptr;
	demographicswindow_pop_row_details_button_t* details_button = nullptr;
	std::string_view texture_key;
	std::string_view alt_texture_key;
	dcon::texture_id alt_background_texture;
	bool is_active = false;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return (type == ui::mouse_probe_type::scroll ? ui::message_result::unseen : ui::message_result::consumed);
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "value") {
			return (void*)(&value);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_pop_row(sys::state& state);
struct demographicswindow_filters_window_t : public ui::container_base {
	demographicswindow_filters_window_job_all_t* job_all = nullptr;
	demographicswindow_filters_window_job_none_t* job_none = nullptr;
	demographicswindow_filters_window_culture_all_t* culture_all = nullptr;
	demographicswindow_filters_window_culture_none_t* culture_none = nullptr;
	demographicswindow_filters_window_religion_all_t* religion_all = nullptr;
	demographicswindow_filters_window_religion_none_t* religion_none = nullptr;
	demographicswindow_filters_window_location_all_t* location_all = nullptr;
	demographicswindow_filters_window_location_none_t* location_none = nullptr;
	demographicswindow_filters_window_non_colonial_t* non_colonial = nullptr;
	demographicswindow_filters_window_colonial_t* colonial = nullptr;
	demographicswindow_filters_window_job_list_t* job_list = nullptr;
	demographicswindow_filters_window_culture_list_t* culture_list = nullptr;
	demographicswindow_filters_window_religion_list_t* religion_list = nullptr;
	demographicswindow_filters_window_location_list_t* location_list = nullptr;
	demographicswindow_filters_window_close_button_t* close_button = nullptr;
	demographicswindow_filters_window_job_left_t* job_left = nullptr;
	demographicswindow_filters_window_culture_left_t* culture_left = nullptr;
	demographicswindow_filters_window_religion_left_t* religion_left = nullptr;
	demographicswindow_filters_window_location_left_t* location_left = nullptr;
	demographicswindow_filters_window_job_right_t* job_right = nullptr;
	demographicswindow_filters_window_culture_right_t* culture_right = nullptr;
	demographicswindow_filters_window_religion_right_t* religion_right = nullptr;
	demographicswindow_filters_window_location_right_t* location_right = nullptr;
	demographicswindow_filters_window_job_page_t* job_page = nullptr;
	demographicswindow_filters_window_culture_page_t* culture_page = nullptr;
	demographicswindow_filters_window_religion_page_t* religion_page = nullptr;
	demographicswindow_filters_window_location_page_t* location_page = nullptr;
	demographicswindow_filters_window_job_header_t* job_header = nullptr;
	demographicswindow_filters_window_culture_header_t* culture_header = nullptr;
	demographicswindow_filters_window_religion_header_t* religion_header = nullptr;
	demographicswindow_filters_window_location_header_t* location_header = nullptr;
	std::string_view texture_key;
	dcon::texture_id background_texture;
	void on_create(sys::state& state) noexcept override;
	void render(sys::state & state, int32_t x, int32_t y) noexcept override;
	ui::message_result on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return (type == ui::mouse_probe_type::scroll ? ui::message_result::unseen : ui::message_result::consumed);
	}
	void on_drag(sys::state& state, int32_t oldx, int32_t oldy, int32_t x, int32_t y, sys::key_modifiers mods) noexcept override {
		auto location_abs = get_absolute_location(state, *this);
		if(location_abs.x <= oldx && oldx < base_data.size.x + location_abs.x && location_abs.y <= oldy && oldy < base_data.size.y + location_abs.y) {
			ui::xy_pair new_abs_pos = location_abs;
			new_abs_pos.x += int16_t(x - oldx);
			new_abs_pos.y += int16_t(y - oldy);
			if(ui::ui_width(state) > base_data.size.x)
				new_abs_pos.x = int16_t(std::clamp(int32_t(new_abs_pos.x), 0, ui::ui_width(state) - base_data.size.x));
			if(ui::ui_height(state) > base_data.size.y)
				new_abs_pos.y = int16_t(std::clamp(int32_t(new_abs_pos.y), 0, ui::ui_height(state) - base_data.size.y));
			if(state.world.locale_get_native_rtl(state.font_collection.get_current_locale())) {
				base_data.position.x -= int16_t(new_abs_pos.x - location_abs.x);
			} else {
				base_data.position.x += int16_t(new_abs_pos.x - location_abs.x);
			}
		base_data.position.y += int16_t(new_abs_pos.y - location_abs.y);
		}
	}
	void on_update(sys::state& state) noexcept override;
};
std::unique_ptr<ui::element_base> make_demographicswindow_filters_window(sys::state& state);
struct demographicswindow_job_filter_t : public ui::container_base {
	dcon::pop_type_id value;
	demographicswindow_job_filter_filter_button_t* filter_button = nullptr;
	demographicswindow_job_filter_icon_t* icon = nullptr;
	demographicswindow_job_filter_filter_label_t* filter_label = nullptr;
	void on_create(sys::state& state) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return ui::message_result::unseen;
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "value") {
			return (void*)(&value);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_job_filter(sys::state& state);
struct demographicswindow_religion_filter_t : public ui::container_base {
	dcon::religion_id value;
	demographicswindow_religion_filter_filter_button_t* filter_button = nullptr;
	demographicswindow_religion_filter_icon_t* icon = nullptr;
	demographicswindow_religion_filter_filter_label_t* filter_label = nullptr;
	void on_create(sys::state& state) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return ui::message_result::unseen;
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "value") {
			return (void*)(&value);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_religion_filter(sys::state& state);
struct demographicswindow_location_filter_t : public ui::container_base {
	dcon::state_instance_id value;
	demographicswindow_location_filter_filter_button_t* filter_button = nullptr;
	demographicswindow_location_filter_filter_label_t* filter_label = nullptr;
	void on_create(sys::state& state) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return ui::message_result::unseen;
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "value") {
			return (void*)(&value);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_location_filter(sys::state& state);
struct demographicswindow_culture_filter_t : public ui::container_base {
	dcon::culture_id value;
	demographicswindow_culture_filter_filter_button_t* filter_button = nullptr;
	demographicswindow_culture_filter_filter_label_t* filter_label = nullptr;
	void on_create(sys::state& state) noexcept override;
	ui::message_result test_mouse(sys::state& state, int32_t x, int32_t y, ui::mouse_probe_type type) noexcept override {
		return ui::message_result::unseen;
	}
	void on_update(sys::state& state) noexcept override;
	void* get_by_name(sys::state& state, std::string_view name) noexcept override {
		if(name == "value") {
			return (void*)(&value);
		}
		return nullptr;
	}
};
std::unique_ptr<ui::element_base> make_demographicswindow_culture_filter(sys::state& state);
ui::message_result demographicswindow_main_close_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN main::close_button::lbutton_action
	parent->set_visible(state, false);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_close_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_close_button_t::on_key_down(sys::state& state, sys::virtual_key key, sys::key_modifiers mods) noexcept {
	if(key == sys::virtual_key::ESCAPE) {
		on_lbutton_down(state, 0, 0, mods);
		return ui::message_result::consumed;
	}
	return ui::message_result::unseen;
}
void demographicswindow_main_close_button_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	text::add_line(state, contents, tooltip_key);
}
void demographicswindow_main_close_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_main_close_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::close_button::update
// END
}
void demographicswindow_main_close_button_t::on_create(sys::state& state) noexcept {
// BEGIN main::close_button::create
// END
}
void demographicswindow_main_title_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_main_title_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_main_title_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_main_title_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::title::update
// END
}
void demographicswindow_main_title_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN main::title::create
// END
}
void demographicswindow_main_main_page_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_main_main_page_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_main_main_page_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_main_main_page_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::main_page::update
	set_text(state, std::to_string(main.table->page + 1) + "/" + std::to_string(1 + main.table->max_page()));
// END
}
void demographicswindow_main_main_page_t::on_create(sys::state& state) noexcept {
// BEGIN main::main_page::create
// END
}
void demographicswindow_main_table_header_t::on_reset_text(sys::state & state) noexcept {
	{
	location_cached_text = text::produce_simple_string(state, location_text_key);
	 location_internal_layout.contents.clear();
	 location_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  location_internal_layout, text::layout_parameters{ 0, 0, int16_t(location_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::location_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, location_cached_text);
	}
	{
	size_cached_text = text::produce_simple_string(state, size_text_key);
	 size_internal_layout.contents.clear();
	 size_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  size_internal_layout, text::layout_parameters{ 0, 0, int16_t(size_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::size_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, size_cached_text);
	}
	{
	culture_cached_text = text::produce_simple_string(state, culture_text_key);
	 culture_internal_layout.contents.clear();
	 culture_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  culture_internal_layout, text::layout_parameters{ 0, 0, int16_t(culture_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::culture_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, culture_cached_text);
	}
	{
	job_cached_text = text::produce_simple_string(state, job_text_key);
	 job_internal_layout.contents.clear();
	 job_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  job_internal_layout, text::layout_parameters{ 0, 0, int16_t(job_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::job_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, job_cached_text);
	}
	{
	religion_cached_text = text::produce_simple_string(state, religion_text_key);
	 religion_internal_layout.contents.clear();
	 religion_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  religion_internal_layout, text::layout_parameters{ 0, 0, int16_t(religion_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::religion_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, religion_cached_text);
	}
	{
	ideology_cached_text = text::produce_simple_string(state, ideology_text_key);
	 ideology_internal_layout.contents.clear();
	 ideology_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  ideology_internal_layout, text::layout_parameters{ 0, 0, int16_t(ideology_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::ideology_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, ideology_cached_text);
	}
	{
	issues_cached_text = text::produce_simple_string(state, issues_text_key);
	 issues_internal_layout.contents.clear();
	 issues_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  issues_internal_layout, text::layout_parameters{ 0, 0, int16_t(issues_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::issues_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, issues_cached_text);
	}
	{
	militancy_cached_text = text::produce_simple_string(state, militancy_text_key);
	 militancy_internal_layout.contents.clear();
	 militancy_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  militancy_internal_layout, text::layout_parameters{ 0, 0, int16_t(militancy_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::militancy_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, militancy_cached_text);
	}
	{
	consciousness_cached_text = text::produce_simple_string(state, consciousness_text_key);
	 consciousness_internal_layout.contents.clear();
	 consciousness_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  consciousness_internal_layout, text::layout_parameters{ 0, 0, int16_t(consciousness_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::consciousness_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, consciousness_cached_text);
	}
	{
	employment_cached_text = text::produce_simple_string(state, employment_text_key);
	 employment_internal_layout.contents.clear();
	 employment_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  employment_internal_layout, text::layout_parameters{ 0, 0, int16_t(employment_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::employment_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, employment_cached_text);
	}
	{
	literacy_cached_text = text::produce_simple_string(state, literacy_text_key);
	 literacy_internal_layout.contents.clear();
	 literacy_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  literacy_internal_layout, text::layout_parameters{ 0, 0, int16_t(literacy_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::literacy_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, literacy_cached_text);
	}
	{
	money_cached_text = text::produce_simple_string(state, money_text_key);
	 money_internal_layout.contents.clear();
	 money_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  money_internal_layout, text::layout_parameters{ 0, 0, int16_t(money_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::money_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, money_cached_text);
	}
	{
	needs_cached_text = text::produce_simple_string(state, needs_text_key);
	 needs_internal_layout.contents.clear();
	 needs_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  needs_internal_layout, text::layout_parameters{ 0, 0, int16_t(needs_column_width - 24 - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::needs_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, needs_cached_text);
	}
	{
	rebels_cached_text = text::produce_simple_string(state, rebels_text_key);
	 rebels_internal_layout.contents.clear();
	 rebels_internal_layout.number_of_lines = 0;
	text::single_line_layout sl{  rebels_internal_layout, text::layout_parameters{ 0, 0, int16_t(rebels_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, demographicswindow_main_table_row_t::rebels_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, rebels_cached_text);
	}
}
void  demographicswindow_main_table_header_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	auto fh = text::make_font_id(state, false, 1.0f * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	auto ycentered = (base_data.size.y - linesz) / 2;
	int32_t rel_mouse_x = int32_t(state.mouse_x_position / state.user_settings.ui_scale) - ui::get_absolute_location(state, *this).x;
		ogl::render_textured_rect(state, ui::get_color_modification(false, false,  false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, demographicswindow_main_table_row_t::row_background_texture, demographicswindow_main_table_row_t::row_texture_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	bool col_um_spacer = rel_mouse_x >= spacer_column_start && rel_mouse_x < (spacer_column_start + spacer_column_width);
	bool col_um_location = rel_mouse_x >= location_column_start && rel_mouse_x < (location_column_start + location_column_width);
	if(col_um_location) {
		ogl::render_alpha_colored_rect(state, float(x + location_column_start), float(y), float(location_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!location_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_location , false, false); 
		for(auto& t : location_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + location_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, location_text_color), cmod);
		}
	}
	bool col_um_size = rel_mouse_x >= size_column_start && rel_mouse_x < (size_column_start + size_column_width);
	if(col_um_size) {
		ogl::render_alpha_colored_rect(state, float(x + size_column_start), float(y), float(size_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(size_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_size, false, true), float(x + size_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(size_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_size, false, true), float(x + size_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!size_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_size , false, true); 
		for(auto& t : size_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + size_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, size_text_color), cmod);
		}
	}
	bool col_um_culture = rel_mouse_x >= culture_column_start && rel_mouse_x < (culture_column_start + culture_column_width);
	if(col_um_culture) {
		ogl::render_alpha_colored_rect(state, float(x + culture_column_start), float(y), float(culture_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(culture_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_culture, false, true), float(x + culture_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(culture_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_culture, false, true), float(x + culture_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!culture_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_culture , false, true); 
		for(auto& t : culture_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + culture_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, culture_text_color), cmod);
		}
	}
	bool col_um_job = rel_mouse_x >= job_column_start && rel_mouse_x < (job_column_start + job_column_width);
	if(col_um_job) {
		ogl::render_alpha_colored_rect(state, float(x + job_column_start), float(y), float(job_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(job_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_job, false, true), float(x + job_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(job_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_job, false, true), float(x + job_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!job_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_job , false, true); 
		for(auto& t : job_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + job_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, job_text_color), cmod);
		}
	}
	bool col_um_religion = rel_mouse_x >= religion_column_start && rel_mouse_x < (religion_column_start + religion_column_width);
	if(col_um_religion) {
		ogl::render_alpha_colored_rect(state, float(x + religion_column_start), float(y), float(religion_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(religion_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_religion, false, true), float(x + religion_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(religion_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_religion, false, true), float(x + religion_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!religion_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_religion , false, true); 
		for(auto& t : religion_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + religion_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, religion_text_color), cmod);
		}
	}
	bool col_um_ideology = rel_mouse_x >= ideology_column_start && rel_mouse_x < (ideology_column_start + ideology_column_width);
	if(col_um_ideology) {
		ogl::render_alpha_colored_rect(state, float(x + ideology_column_start), float(y), float(ideology_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!ideology_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_ideology , false, false); 
		for(auto& t : ideology_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + ideology_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, ideology_text_color), cmod);
		}
	}
	bool col_um_issues = rel_mouse_x >= issues_column_start && rel_mouse_x < (issues_column_start + issues_column_width);
	if(col_um_issues) {
		ogl::render_alpha_colored_rect(state, float(x + issues_column_start), float(y), float(issues_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!issues_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_issues , false, false); 
		for(auto& t : issues_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + issues_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, issues_text_color), cmod);
		}
	}
	bool col_um_militancy = rel_mouse_x >= militancy_column_start && rel_mouse_x < (militancy_column_start + militancy_column_width);
	if(col_um_militancy) {
		ogl::render_alpha_colored_rect(state, float(x + militancy_column_start), float(y), float(militancy_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(militancy_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_militancy, false, true), float(x + militancy_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(militancy_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_militancy, false, true), float(x + militancy_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!militancy_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_militancy , false, true); 
		for(auto& t : militancy_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + militancy_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, militancy_text_color), cmod);
		}
	}
	bool col_um_consciousness = rel_mouse_x >= consciousness_column_start && rel_mouse_x < (consciousness_column_start + consciousness_column_width);
	if(col_um_consciousness) {
		ogl::render_alpha_colored_rect(state, float(x + consciousness_column_start), float(y), float(consciousness_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(consciousness_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_consciousness, false, true), float(x + consciousness_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(consciousness_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_consciousness, false, true), float(x + consciousness_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!consciousness_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_consciousness , false, true); 
		for(auto& t : consciousness_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + consciousness_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, consciousness_text_color), cmod);
		}
	}
	bool col_um_employment = rel_mouse_x >= employment_column_start && rel_mouse_x < (employment_column_start + employment_column_width);
	if(col_um_employment) {
		ogl::render_alpha_colored_rect(state, float(x + employment_column_start), float(y), float(employment_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(employment_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_employment, false, true), float(x + employment_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(employment_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_employment, false, true), float(x + employment_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!employment_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_employment , false, true); 
		for(auto& t : employment_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + employment_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, employment_text_color), cmod);
		}
	}
	bool col_um_literacy = rel_mouse_x >= literacy_column_start && rel_mouse_x < (literacy_column_start + literacy_column_width);
	if(col_um_literacy) {
		ogl::render_alpha_colored_rect(state, float(x + literacy_column_start), float(y), float(literacy_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(literacy_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_literacy, false, true), float(x + literacy_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(literacy_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_literacy, false, true), float(x + literacy_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!literacy_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_literacy , false, true); 
		for(auto& t : literacy_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + literacy_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, literacy_text_color), cmod);
		}
	}
	bool col_um_money = rel_mouse_x >= money_column_start && rel_mouse_x < (money_column_start + money_column_width);
	if(col_um_money) {
		ogl::render_alpha_colored_rect(state, float(x + money_column_start), float(y), float(money_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(money_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_money, false, true), float(x + money_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(money_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_money, false, true), float(x + money_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!money_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_money , false, true); 
		for(auto& t : money_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + money_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, money_text_color), cmod);
		}
	}
	bool col_um_needs = rel_mouse_x >= needs_column_start && rel_mouse_x < (needs_column_start + needs_column_width);
	if(col_um_needs) {
		ogl::render_alpha_colored_rect(state, float(x + needs_column_start), float(y), float(needs_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
if(needs_sort_direction > 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_needs, false, true), float(x + needs_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, ascending_icon, ascending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
if(needs_sort_direction < 0) {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse && col_um_needs, false, true), float(x + needs_column_start + 8), float(y + base_data.size.y / 2 - 8), float(16), float(16), ogl::get_late_load_texture_handle(state, descending_icon, descending_icon_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
	if(!needs_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_needs , false, true); 
		for(auto& t : needs_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + needs_column_start + 24 + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, needs_text_color), cmod);
		}
	}
	bool col_um_rebels = rel_mouse_x >= rebels_column_start && rel_mouse_x < (rebels_column_start + rebels_column_width);
	if(col_um_rebels) {
		ogl::render_alpha_colored_rect(state, float(x + rebels_column_start), float(y), float(rebels_column_width), float(base_data.size.y),demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!rebels_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_rebels , false, false); 
		for(auto& t : rebels_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + rebels_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, rebels_text_color), cmod);
		}
	}
	ogl::render_alpha_colored_rect(state, float(x), float(y + base_data.size.y - 1), float(base_data.size.x), float(1), demographicswindow_main_table_t::table_divider_color.r, demographicswindow_main_table_t::table_divider_color.g, demographicswindow_main_table_t::table_divider_color.b, 1.0f);
}
ui::message_result demographicswindow_main_table_header_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	if(x >= size_column_start && x < size_column_start + size_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = size_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		size_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= culture_column_start && x < culture_column_start + culture_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = culture_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		culture_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= job_column_start && x < job_column_start + job_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = job_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		job_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= religion_column_start && x < religion_column_start + religion_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = religion_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		religion_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= militancy_column_start && x < militancy_column_start + militancy_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = militancy_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		militancy_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= consciousness_column_start && x < consciousness_column_start + consciousness_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = consciousness_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		consciousness_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= employment_column_start && x < employment_column_start + employment_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = employment_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		employment_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= literacy_column_start && x < literacy_column_start + literacy_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = literacy_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		literacy_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= money_column_start && x < money_column_start + money_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = money_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		money_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	if(x >= needs_column_start && x < needs_column_start + needs_column_width) {
		sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
		auto old_direction = needs_sort_direction;
		size_sort_direction = 0;
		culture_sort_direction = 0;
		job_sort_direction = 0;
		religion_sort_direction = 0;
		militancy_sort_direction = 0;
		consciousness_sort_direction = 0;
		employment_sort_direction = 0;
		literacy_sort_direction = 0;
		money_sort_direction = 0;
		needs_sort_direction = 0;
		needs_sort_direction = int8_t(old_direction <= 0 ? 1 : -1);
		(( demographicswindow_main_table_t*)parent)->apply_sort(state);
	}
	return ui::message_result::consumed;}
ui::message_result demographicswindow_main_table_header_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;}
void demographicswindow_main_table_header_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	if(x >= spacer_column_start && x < spacer_column_start + spacer_column_width) {
	}
	if(x >= location_column_start && x < location_column_start + location_column_width) {
	}
	if(x >= size_column_start && x < size_column_start + size_column_width) {
	}
	if(x >= culture_column_start && x < culture_column_start + culture_column_width) {
	}
	if(x >= job_column_start && x < job_column_start + job_column_width) {
	}
	if(x >= religion_column_start && x < religion_column_start + religion_column_width) {
	}
	if(x >= ideology_column_start && x < ideology_column_start + ideology_column_width) {
	}
	if(x >= issues_column_start && x < issues_column_start + issues_column_width) {
	}
	if(x >= militancy_column_start && x < militancy_column_start + militancy_column_width) {
	}
	if(x >= consciousness_column_start && x < consciousness_column_start + consciousness_column_width) {
	}
	if(x >= employment_column_start && x < employment_column_start + employment_column_width) {
	}
	if(x >= literacy_column_start && x < literacy_column_start + literacy_column_width) {
	}
	if(x >= money_column_start && x < money_column_start + money_column_width) {
	}
	if(x >= needs_column_start && x < needs_column_start + needs_column_width) {
	}
	if(x >= rebels_column_start && x < rebels_column_start + rebels_column_width) {
	}
}
void demographicswindow_main_table_header_t::tooltip_position(sys::state& state, int32_t x, int32_t y, int32_t& ident, ui::urect& subrect) noexcept {
	if(x >= spacer_column_start && x < spacer_column_start + spacer_column_width) {
	}
	if(x >= location_column_start && x < location_column_start + location_column_width) {
	}
	if(x >= size_column_start && x < size_column_start + size_column_width) {
	}
	if(x >= culture_column_start && x < culture_column_start + culture_column_width) {
	}
	if(x >= job_column_start && x < job_column_start + job_column_width) {
	}
	if(x >= religion_column_start && x < religion_column_start + religion_column_width) {
	}
	if(x >= ideology_column_start && x < ideology_column_start + ideology_column_width) {
	}
	if(x >= issues_column_start && x < issues_column_start + issues_column_width) {
	}
	if(x >= militancy_column_start && x < militancy_column_start + militancy_column_width) {
	}
	if(x >= consciousness_column_start && x < consciousness_column_start + consciousness_column_width) {
	}
	if(x >= employment_column_start && x < employment_column_start + employment_column_width) {
	}
	if(x >= literacy_column_start && x < literacy_column_start + literacy_column_width) {
	}
	if(x >= money_column_start && x < money_column_start + money_column_width) {
	}
	if(x >= needs_column_start && x < needs_column_start + needs_column_width) {
	}
	if(x >= rebels_column_start && x < rebels_column_start + rebels_column_width) {
	}
		ident = -1;
		subrect.top_left = ui::get_absolute_location(state, *this);
		subrect.size = base_data.size;
}
void demographicswindow_main_table_header_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
}
void  demographicswindow_main_table_row_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	auto fh = text::make_font_id(state, false, 1.0f * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	auto ycentered = (base_data.size.y - linesz) / 2;
	int32_t rel_mouse_x = int32_t(state.mouse_x_position / state.user_settings.ui_scale) - ui::get_absolute_location(state, *this).x;
	if(alternate_row) {
		ogl::render_textured_rect(state, ui::get_color_modification(false, false,  false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_row_background_texture, alt_row_texture_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	} else {
		ogl::render_textured_rect(state, ui::get_color_modification(false, false,  false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, row_background_texture, row_texture_key), ui::rotation::upright, false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	}
	if(this == state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x ), float(y), float(base_data.size.x), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_spacer = rel_mouse_x >= demographicswindow_main_table_header_t::spacer_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::spacer_column_start + demographicswindow_main_table_header_t::spacer_column_width);
	bool col_um_location = rel_mouse_x >= demographicswindow_main_table_header_t::location_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::location_column_start + demographicswindow_main_table_header_t::location_column_width);
	if(col_um_location && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::location_column_start), float(y), float(demographicswindow_main_table_header_t::location_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!location_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_location , false, false); 
		for(auto& t : location_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::location_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, location_text_color), cmod);
	}
	}
	bool col_um_size = rel_mouse_x >= demographicswindow_main_table_header_t::size_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::size_column_start + demographicswindow_main_table_header_t::size_column_width);
	if(col_um_size && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::size_column_start), float(y), float(demographicswindow_main_table_header_t::size_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!size_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_size , false, false); 
		for(auto& t : size_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::size_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, size_text_color), cmod);
	}
	}
	bool col_um_culture = rel_mouse_x >= demographicswindow_main_table_header_t::culture_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::culture_column_start + demographicswindow_main_table_header_t::culture_column_width);
	if(col_um_culture && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::culture_column_start), float(y), float(demographicswindow_main_table_header_t::culture_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!culture_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_culture , false, false); 
		for(auto& t : culture_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::culture_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, culture_text_color), cmod);
	}
	}
	bool col_um_job = rel_mouse_x >= demographicswindow_main_table_header_t::job_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::job_column_start + demographicswindow_main_table_header_t::job_column_width);
	if(col_um_job && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::job_column_start), float(y), float(demographicswindow_main_table_header_t::job_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!job_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_job , false, false); 
		for(auto& t : job_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::job_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, job_text_color), cmod);
	}
	}
	bool col_um_religion = rel_mouse_x >= demographicswindow_main_table_header_t::religion_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::religion_column_start + demographicswindow_main_table_header_t::religion_column_width);
	if(col_um_religion && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::religion_column_start), float(y), float(demographicswindow_main_table_header_t::religion_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!religion_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_religion , false, false); 
		for(auto& t : religion_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::religion_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, religion_text_color), cmod);
	}
	}
	bool col_um_ideology = rel_mouse_x >= demographicswindow_main_table_header_t::ideology_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::ideology_column_start + demographicswindow_main_table_header_t::ideology_column_width);
	if(col_um_ideology && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::ideology_column_start), float(y), float(demographicswindow_main_table_header_t::ideology_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!ideology_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_ideology , false, false); 
		for(auto& t : ideology_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::ideology_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, ideology_text_color), cmod);
	}
	}
	bool col_um_issues = rel_mouse_x >= demographicswindow_main_table_header_t::issues_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::issues_column_start + demographicswindow_main_table_header_t::issues_column_width);
	if(col_um_issues && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::issues_column_start), float(y), float(demographicswindow_main_table_header_t::issues_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!issues_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_issues , false, false); 
		for(auto& t : issues_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::issues_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, issues_text_color), cmod);
	}
	}
	bool col_um_militancy = rel_mouse_x >= demographicswindow_main_table_header_t::militancy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::militancy_column_start + demographicswindow_main_table_header_t::militancy_column_width);
	if(col_um_militancy && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::militancy_column_start), float(y), float(demographicswindow_main_table_header_t::militancy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!militancy_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_militancy , false, false); 
		for(auto& t : militancy_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::militancy_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, militancy_text_color), cmod);
	}
	}
	bool col_um_consciousness = rel_mouse_x >= demographicswindow_main_table_header_t::consciousness_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::consciousness_column_start + demographicswindow_main_table_header_t::consciousness_column_width);
	if(col_um_consciousness && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::consciousness_column_start), float(y), float(demographicswindow_main_table_header_t::consciousness_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!consciousness_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_consciousness , false, false); 
		for(auto& t : consciousness_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::consciousness_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, consciousness_text_color), cmod);
	}
	}
	bool col_um_employment = rel_mouse_x >= demographicswindow_main_table_header_t::employment_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::employment_column_start + demographicswindow_main_table_header_t::employment_column_width);
	if(col_um_employment && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::employment_column_start), float(y), float(demographicswindow_main_table_header_t::employment_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!employment_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_employment , false, false); 
		for(auto& t : employment_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::employment_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, employment_text_color), cmod);
	}
	}
	bool col_um_literacy = rel_mouse_x >= demographicswindow_main_table_header_t::literacy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::literacy_column_start + demographicswindow_main_table_header_t::literacy_column_width);
	if(col_um_literacy && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::literacy_column_start), float(y), float(demographicswindow_main_table_header_t::literacy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!literacy_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_literacy , false, false); 
		for(auto& t : literacy_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::literacy_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, literacy_text_color), cmod);
	}
	}
	bool col_um_money = rel_mouse_x >= demographicswindow_main_table_header_t::money_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::money_column_start + demographicswindow_main_table_header_t::money_column_width);
	if(col_um_money && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::money_column_start), float(y), float(demographicswindow_main_table_header_t::money_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!money_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_money , false, false); 
		for(auto& t : money_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::money_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, money_text_color), cmod);
	}
	}
	bool col_um_needs = rel_mouse_x >= demographicswindow_main_table_header_t::needs_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::needs_column_start + demographicswindow_main_table_header_t::needs_column_width);
	if(col_um_needs && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::needs_column_start), float(y), float(demographicswindow_main_table_header_t::needs_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!needs_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_needs , false, false); 
		for(auto& t : needs_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::needs_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, needs_text_color), cmod);
	}
	}
	bool col_um_rebels = rel_mouse_x >= demographicswindow_main_table_header_t::rebels_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::rebels_column_start + demographicswindow_main_table_header_t::rebels_column_width);
	if(col_um_rebels && this != state.ui_state.under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::rebels_column_start), float(y), float(demographicswindow_main_table_header_t::rebels_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	if(!rebels_internal_layout.contents.empty() && linesz > 0.0f) {
		auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse && col_um_rebels , false, false); 
		for(auto& t : rebels_internal_layout.contents) {
			ui::render_text_chunk(state, t, float(x) + t.x + demographicswindow_main_table_header_t::rebels_column_start + 8, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, rebels_text_color), cmod);
	}
	}
}
ui::message_result demographicswindow_main_table_row_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;}
ui::message_result demographicswindow_main_table_row_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;}
void demographicswindow_main_table_row_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	if(x >= demographicswindow_main_table_header_t::spacer_column_start && x < demographicswindow_main_table_header_t::spacer_column_start + demographicswindow_main_table_header_t::spacer_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::location_column_start && x < demographicswindow_main_table_header_t::location_column_start + demographicswindow_main_table_header_t::location_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::size_column_start && x < demographicswindow_main_table_header_t::size_column_start + demographicswindow_main_table_header_t::size_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::culture_column_start && x < demographicswindow_main_table_header_t::culture_column_start + demographicswindow_main_table_header_t::culture_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::job_column_start && x < demographicswindow_main_table_header_t::job_column_start + demographicswindow_main_table_header_t::job_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::religion_column_start && x < demographicswindow_main_table_header_t::religion_column_start + demographicswindow_main_table_header_t::religion_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::ideology_column_start && x < demographicswindow_main_table_header_t::ideology_column_start + demographicswindow_main_table_header_t::ideology_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::issues_column_start && x < demographicswindow_main_table_header_t::issues_column_start + demographicswindow_main_table_header_t::issues_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::militancy_column_start && x < demographicswindow_main_table_header_t::militancy_column_start + demographicswindow_main_table_header_t::militancy_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::consciousness_column_start && x < demographicswindow_main_table_header_t::consciousness_column_start + demographicswindow_main_table_header_t::consciousness_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::employment_column_start && x < demographicswindow_main_table_header_t::employment_column_start + demographicswindow_main_table_header_t::employment_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::literacy_column_start && x < demographicswindow_main_table_header_t::literacy_column_start + demographicswindow_main_table_header_t::literacy_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::money_column_start && x < demographicswindow_main_table_header_t::money_column_start + demographicswindow_main_table_header_t::money_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::needs_column_start && x < demographicswindow_main_table_header_t::needs_column_start + demographicswindow_main_table_header_t::needs_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::rebels_column_start && x < demographicswindow_main_table_header_t::rebels_column_start + demographicswindow_main_table_header_t::rebels_column_width) {
	}
}
void demographicswindow_main_table_row_t::tooltip_position(sys::state& state, int32_t x, int32_t y, int32_t& ident, ui::urect& subrect) noexcept {
	if(x >= demographicswindow_main_table_header_t::spacer_column_start && x < demographicswindow_main_table_header_t::spacer_column_start + demographicswindow_main_table_header_t::spacer_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::location_column_start && x < demographicswindow_main_table_header_t::location_column_start + demographicswindow_main_table_header_t::location_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::size_column_start && x < demographicswindow_main_table_header_t::size_column_start + demographicswindow_main_table_header_t::size_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::culture_column_start && x < demographicswindow_main_table_header_t::culture_column_start + demographicswindow_main_table_header_t::culture_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::job_column_start && x < demographicswindow_main_table_header_t::job_column_start + demographicswindow_main_table_header_t::job_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::religion_column_start && x < demographicswindow_main_table_header_t::religion_column_start + demographicswindow_main_table_header_t::religion_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::ideology_column_start && x < demographicswindow_main_table_header_t::ideology_column_start + demographicswindow_main_table_header_t::ideology_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::issues_column_start && x < demographicswindow_main_table_header_t::issues_column_start + demographicswindow_main_table_header_t::issues_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::militancy_column_start && x < demographicswindow_main_table_header_t::militancy_column_start + demographicswindow_main_table_header_t::militancy_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::consciousness_column_start && x < demographicswindow_main_table_header_t::consciousness_column_start + demographicswindow_main_table_header_t::consciousness_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::employment_column_start && x < demographicswindow_main_table_header_t::employment_column_start + demographicswindow_main_table_header_t::employment_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::literacy_column_start && x < demographicswindow_main_table_header_t::literacy_column_start + demographicswindow_main_table_header_t::literacy_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::money_column_start && x < demographicswindow_main_table_header_t::money_column_start + demographicswindow_main_table_header_t::money_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::needs_column_start && x < demographicswindow_main_table_header_t::needs_column_start + demographicswindow_main_table_header_t::needs_column_width) {
	}
	if(x >= demographicswindow_main_table_header_t::rebels_column_start && x < demographicswindow_main_table_header_t::rebels_column_start + demographicswindow_main_table_header_t::rebels_column_width) {
	}
		ident = -1;
		subrect.top_left = ui::get_absolute_location(state, *this);
		subrect.size = base_data.size;
}
void demographicswindow_main_table_row_t::on_create(sys::state& state) noexcept {
}
void demographicswindow_main_table_row_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_table_t& table = *((demographicswindow_main_table_t*)(parent)); 
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent->parent)); 
// BEGIN main::table::row_update
// END
}
void demographicswindow_main_table_row_t::set_location_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  location_cached_text) {
		location_cached_text = new_text;
		location_internal_layout.contents.clear();
		location_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ location_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::location_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, location_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, location_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_size_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  size_cached_text) {
		size_cached_text = new_text;
		size_internal_layout.contents.clear();
		size_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ size_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::size_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, size_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, size_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_culture_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  culture_cached_text) {
		culture_cached_text = new_text;
		culture_internal_layout.contents.clear();
		culture_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ culture_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::culture_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, culture_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, culture_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_job_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  job_cached_text) {
		job_cached_text = new_text;
		job_internal_layout.contents.clear();
		job_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ job_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::job_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, job_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, job_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_religion_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  religion_cached_text) {
		religion_cached_text = new_text;
		religion_internal_layout.contents.clear();
		religion_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ religion_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::religion_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, religion_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, religion_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_ideology_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  ideology_cached_text) {
		ideology_cached_text = new_text;
		ideology_internal_layout.contents.clear();
		ideology_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ ideology_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::ideology_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, ideology_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, ideology_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_issues_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  issues_cached_text) {
		issues_cached_text = new_text;
		issues_internal_layout.contents.clear();
		issues_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ issues_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::issues_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, issues_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, issues_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_militancy_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  militancy_cached_text) {
		militancy_cached_text = new_text;
		militancy_internal_layout.contents.clear();
		militancy_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ militancy_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::militancy_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, militancy_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, militancy_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_consciousness_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  consciousness_cached_text) {
		consciousness_cached_text = new_text;
		consciousness_internal_layout.contents.clear();
		consciousness_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ consciousness_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::consciousness_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, consciousness_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, consciousness_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_employment_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  employment_cached_text) {
		employment_cached_text = new_text;
		employment_internal_layout.contents.clear();
		employment_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ employment_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::employment_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, employment_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, employment_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_literacy_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  literacy_cached_text) {
		literacy_cached_text = new_text;
		literacy_internal_layout.contents.clear();
		literacy_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ literacy_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::literacy_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, literacy_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, literacy_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_money_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  money_cached_text) {
		money_cached_text = new_text;
		money_internal_layout.contents.clear();
		money_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ money_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::money_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, money_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, money_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_needs_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  needs_cached_text) {
		needs_cached_text = new_text;
		needs_internal_layout.contents.clear();
		needs_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ needs_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::needs_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, needs_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, needs_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_row_t::set_rebels_text(sys::state & state, std::string const& new_text) {
	if(new_text !=  rebels_cached_text) {
		rebels_cached_text = new_text;
		rebels_internal_layout.contents.clear();
		rebels_internal_layout.number_of_lines = 0;
		{
		text::single_line_layout sl{ rebels_internal_layout, text::layout_parameters{ 0, 0, int16_t(demographicswindow_main_table_header_t::rebels_column_width - 16), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, false, 1.0f * 16), 0, rebels_text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr }; 
		sl.add_text(state, rebels_cached_text);
		}
	} else {
	}
}
void demographicswindow_main_table_t::impl_change_page(sys::state & state, int32_t new_page){
	size_t nation_row_pool_used = 0;
	size_t state_row_pool_used = 0;
	size_t province_row_pool_used = 0;
	size_t pop_row_pool_used = 0;
	size_t row_pool_used = 0;
	size_t header_pool_used = 0;
	int16_t vert_used = 0;
	bool alt_bg  = true;
	page = std::clamp(new_page, 0, max_page());
	children.clear();
	if(page_starts.empty()) return;
	if(open_page) { page_starts.push_back(int32_t(values.size())); open_page = false; }
	for(int32_t i = page_starts[page]; i < page_starts[page + 1]; ++i) {
		if(std::holds_alternative<nation_row_option>(values[i])) {
			if(nation_row_pool_used >= nation_row_pool.size()) nation_row_pool.emplace_back(make_demographicswindow_nation_row(state));
			children.push_back(nation_row_pool[nation_row_pool_used].get());
			children.back()->parent = this;
			((demographicswindow_nation_row_t*)(nation_row_pool[nation_row_pool_used].get()))->content = std::get<nation_row_option>(values[i]).content;
			nation_row_pool[nation_row_pool_used]->base_data.position.y = vert_used;
			vert_used += nation_row_pool[nation_row_pool_used]->base_data.size.y;
			((demographicswindow_nation_row_t*)(nation_row_pool[nation_row_pool_used].get()))->is_active = alt_bg;
			alt_bg  = !alt_bg;
			++nation_row_pool_used;
		}
		if(std::holds_alternative<state_row_option>(values[i])) {
			if(state_row_pool_used >= state_row_pool.size()) state_row_pool.emplace_back(make_demographicswindow_state_row(state));
			children.push_back(state_row_pool[state_row_pool_used].get());
			children.back()->parent = this;
			((demographicswindow_state_row_t*)(state_row_pool[state_row_pool_used].get()))->content = std::get<state_row_option>(values[i]).content;
			state_row_pool[state_row_pool_used]->base_data.position.y = vert_used;
			vert_used += state_row_pool[state_row_pool_used]->base_data.size.y;
			((demographicswindow_state_row_t*)(state_row_pool[state_row_pool_used].get()))->is_active = alt_bg;
			alt_bg  = !alt_bg;
			++state_row_pool_used;
		}
		if(std::holds_alternative<province_row_option>(values[i])) {
			if(province_row_pool_used >= province_row_pool.size()) province_row_pool.emplace_back(make_demographicswindow_province_row(state));
			children.push_back(province_row_pool[province_row_pool_used].get());
			children.back()->parent = this;
			((demographicswindow_province_row_t*)(province_row_pool[province_row_pool_used].get()))->content = std::get<province_row_option>(values[i]).content;
			province_row_pool[province_row_pool_used]->base_data.position.y = vert_used;
			vert_used += province_row_pool[province_row_pool_used]->base_data.size.y;
			((demographicswindow_province_row_t*)(province_row_pool[province_row_pool_used].get()))->is_active = alt_bg;
			alt_bg  = !alt_bg;
			++province_row_pool_used;
		}
		if(std::holds_alternative<pop_row_option>(values[i])) {
			if(pop_row_pool_used >= pop_row_pool.size()) pop_row_pool.emplace_back(make_demographicswindow_pop_row(state));
			children.push_back(pop_row_pool[pop_row_pool_used].get());
			children.back()->parent = this;
			((demographicswindow_pop_row_t*)(pop_row_pool[pop_row_pool_used].get()))->value = std::get<pop_row_option>(values[i]).value;
			pop_row_pool[pop_row_pool_used]->base_data.position.y = vert_used;
			vert_used += pop_row_pool[pop_row_pool_used]->base_data.size.y;
			((demographicswindow_pop_row_t*)(pop_row_pool[pop_row_pool_used].get()))->is_active = alt_bg;
			alt_bg  = !alt_bg;
			++pop_row_pool_used;
		}
		if(std::holds_alternative<value_option>(values[i])) {
			if(row_pool_used >= row_pool.size())row_pool.emplace_back(make_row(state));
			children.push_back(row_pool[row_pool_used].get());
			children.back()->parent = this;
			row_pool[row_pool_used]->value = std::get<value_option>(values[i]).value;
			row_pool[row_pool_used]->alternate_row = alt_bg;
			row_pool[row_pool_used]->base_data.position.y = vert_used;
			vert_used += row_pool[row_pool_used]->base_data.size.y;
			++row_pool_used;
			alt_bg  = !alt_bg;
		}
		if(std::holds_alternative<std::monostate>(values[i])) {
			if(header_pool_used >= header_pool.size()) header_pool.emplace_back(make_headers(state));
			children.push_back(header_pool[header_pool_used].get());
			children.back()->parent = this;
			header_pool[header_pool_used]->base_data.position.y = vert_used;
			vert_used += header_pool[header_pool_used]->base_data.size.y;
			++header_pool_used;
			alt_bg  = true;
		}
	}
}
void demographicswindow_main_table_t::change_page(sys::state & state, int32_t new_page){
	bool lflip = new_page < page && page > 0;
	bool rflip = new_page > page && page < max_page();
	if(rflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_up, 200); 
	} else if(lflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_up_rev, 200);
	}
	impl_change_page(state, new_page);	for(auto c : children) c->impl_on_update(state);
	state.game_state_updated.store(true, std::memory_order::release);
	if(rflip || lflip) {
		state.ui_animation.post_update_frame(state);
	}
}
int32_t demographicswindow_main_table_t::max_page(){
	return open_page ? std::max(int32_t(page_starts.size()) - 1, 0) : std::max(int32_t(page_starts.size()) - 2, 0);
}
void demographicswindow_main_table_t::clear_table() {
	children.clear();
	page_starts.clear();
	values.clear();
	open_page = false;
	layout_space = 0;
}
void demographicswindow_main_table_t::add_value(dcon::pop_id const& v) {
	if(!open_page) {
		page_starts.push_back(0);
		open_page = true;
	}
	if(values.empty()) {
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	if(base_data.size.y - layout_space <= int32_t(row_height * 8)) {
		page_starts.push_back(int32_t(values.size()));
		layout_space = 0;
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	values.emplace_back(value_option{v});
	layout_space += int16_t(row_height * 8);
}
void demographicswindow_main_table_t::add_insert_nation_row(sys::state& state, dcon::nation_id const& content) {
	if(nation_row_pool.empty()) nation_row_pool.emplace_back(make_demographicswindow_nation_row(state));
	if(!open_page) {
		page_starts.push_back(0);
		open_page = true;
	}
	if(values.empty()) {
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	if(base_data.size.y - layout_space <=  nation_row_pool[0]->base_data.size.y) {
		page_starts.push_back(int32_t(values.size()));
		layout_space = 0;
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	values.emplace_back(nation_row_option{content});
	layout_space += int16_t(nation_row_pool[0]->base_data.size.y);
}
void demographicswindow_main_table_t::add_insert_state_row(sys::state& state, dcon::state_instance_id const& content) {
	if(state_row_pool.empty()) state_row_pool.emplace_back(make_demographicswindow_state_row(state));
	if(!open_page) {
		page_starts.push_back(0);
		open_page = true;
	}
	if(values.empty()) {
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	if(base_data.size.y - layout_space <=  state_row_pool[0]->base_data.size.y) {
		page_starts.push_back(int32_t(values.size()));
		layout_space = 0;
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	values.emplace_back(state_row_option{content});
	layout_space += int16_t(state_row_pool[0]->base_data.size.y);
}
void demographicswindow_main_table_t::add_insert_province_row(sys::state& state, dcon::province_id const& content) {
	if(province_row_pool.empty()) province_row_pool.emplace_back(make_demographicswindow_province_row(state));
	if(!open_page) {
		page_starts.push_back(0);
		open_page = true;
	}
	if(values.empty()) {
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	if(base_data.size.y - layout_space <=  province_row_pool[0]->base_data.size.y) {
		page_starts.push_back(int32_t(values.size()));
		layout_space = 0;
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	values.emplace_back(province_row_option{content});
	layout_space += int16_t(province_row_pool[0]->base_data.size.y);
}
void demographicswindow_main_table_t::add_insert_pop_row(sys::state& state, dcon::pop_id const& value) {
	if(pop_row_pool.empty()) pop_row_pool.emplace_back(make_demographicswindow_pop_row(state));
	if(!open_page) {
		page_starts.push_back(0);
		open_page = true;
	}
	if(values.empty()) {
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	if(base_data.size.y - layout_space <=  pop_row_pool[0]->base_data.size.y) {
		page_starts.push_back(int32_t(values.size()));
		layout_space = 0;
		values.emplace_back(std::monostate{});
		layout_space += int16_t(row_height * 8);
	}
	values.emplace_back(pop_row_option{value});
	layout_space += int16_t(pop_row_pool[0]->base_data.size.y);
}
std::unique_ptr<demographicswindow_main_table_row_t> demographicswindow_main_table_t::make_row(sys::state& state) {
	auto cptr = std::make_unique<demographicswindow_main_table_row_t>();
	cptr->parent = this;
	cptr->base_data.position.x = 0;
	cptr->base_data.position.y = 0;
	cptr->base_data.size.y = int16_t(row_height * 8);
	cptr->base_data.size.x = this->base_data.size.x;
	cptr->on_create(state);
	return cptr;
}
std::unique_ptr<demographicswindow_main_table_header_t> demographicswindow_main_table_t::make_headers(sys::state& state){
	auto cptr = std::make_unique<demographicswindow_main_table_header_t>();
	cptr->parent = this;
	cptr->base_data.position.x = 0;
	cptr->base_data.position.y = 0;
	cptr->base_data.size.y = int16_t(row_height * 8);
	cptr->base_data.size.x = this->base_data.size.x;
	cptr->on_create(state);
	return cptr;
}
void demographicswindow_main_table_t::impl_apply_sort(sys::state& state) {
	bool work_to_do = false;
	if(demographicswindow_main_table_header_t::size_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::culture_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::job_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::religion_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::militancy_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::consciousness_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::employment_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::literacy_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::money_sort_direction != 0) work_to_do = true;
	if(demographicswindow_main_table_header_t::needs_sort_direction != 0) work_to_do = true;
	if(!work_to_do) return;
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
	std::vector<dcon::pop_id> val_temp;
	size_t i = 0;
	while(i < values.size()) {
		if(std::holds_alternative<value_option>(values[i]) || std::holds_alternative<pop_row_option>(values[i])) {
			auto start_pos = i;
			do {
				if(std::holds_alternative<value_option>(values[i])) val_temp.push_back(std::get<value_option>(values[i]).value);
				if(std::holds_alternative<pop_row_option>(values[i])) val_temp.push_back(std::get<pop_row_option>(values[i]).value);
				++i;
			} while(i < values.size() && (std::holds_alternative<value_option>(values[i]) || std::holds_alternative<pop_row_option>(values[i]) || std::holds_alternative<std::monostate>(values[i])));
			if(demographicswindow_main_table_header_t::size_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::size
// END
					return result == demographicswindow_main_table_header_t::size_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::culture_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::culture
// END
					return result == demographicswindow_main_table_header_t::culture_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::job_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::job
// END
					return result == demographicswindow_main_table_header_t::job_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::religion_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::religion
// END
					return result == demographicswindow_main_table_header_t::religion_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::militancy_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::militancy
// END
					return result == demographicswindow_main_table_header_t::militancy_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::consciousness_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::consciousness
// END
					return result == demographicswindow_main_table_header_t::consciousness_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::employment_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::employment
// END
					return result == demographicswindow_main_table_header_t::employment_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::literacy_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::literacy
// END
					return result == demographicswindow_main_table_header_t::literacy_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::money_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::money
// END
					return result == demographicswindow_main_table_header_t::money_sort_direction;
				});
			}
			if(demographicswindow_main_table_header_t::needs_sort_direction != 0) {
				sys::merge_sort(val_temp.begin(), val_temp.end(), [&](const dcon::pop_id& a, const dcon::pop_id& b){
					int8_t result = 0;
// BEGIN main::table::sort::needs
// END
					return result == demographicswindow_main_table_header_t::needs_sort_direction;
				});
			}
			while(start_pos < i) {
				if(std::holds_alternative<value_option>(values[start_pos])) {
					std::get<value_option>(values[start_pos]).value = val_temp.back();
					val_temp.pop_back();
				}
				if(std::holds_alternative<pop_row_option>(values[start_pos])) {
					std::get<pop_row_option>(values[start_pos]).value = val_temp.back();
					val_temp.pop_back();
				}
				++start_pos;
			}
			val_temp.clear();
		} else {
			++i;
		}
	}
}
void demographicswindow_main_table_t::apply_sort(sys::state& state) {
	impl_apply_sort(state);
	impl_change_page(state, page);	for(auto c : children) c->impl_on_update(state);
}
ui::message_result demographicswindow_main_table_t::on_scroll(sys::state& state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept {
	change_page(state, page + ((amount < 0) ? 1 : -1));
	return ui::message_result::consumed;
}
void demographicswindow_main_table_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::table::update
	clear_table();
	if(!popwindow::show_only_pops) {
		add_insert_nation_row(state, state.local_player_nation);

		std::vector<dcon::state_instance_id> si;
		for(auto so : state.world.nation_get_state_ownership(state.local_player_nation)) {
			si.push_back(so.get_state().id);
		}
		sys::merge_sort(si.begin(), si.end(), [&](dcon::state_instance_id a, dcon::state_instance_id b) {
			if(!state.world.state_instance_get_capital(a).get_is_colonial() && state.world.state_instance_get_capital(b).get_is_colonial()) {
				return true;
			}
			if(state.world.state_instance_get_capital(a).get_is_colonial() && !state.world.state_instance_get_capital(b).get_is_colonial()) {
				return false;
			}
			// return state.world.state_instance_get_demographics(a, demographics::total) > state.world.state_instance_get_demographics(b, demographics::total);
			return text::get_short_state_name(state, a) < text::get_short_state_name(state, b);
		});
		for(auto s : si) {
			bool added_header = false;
			bool state_is_open = popwindow::open_states.contains(s.index());

			std::vector<dcon::province_id> provs;
			province::for_each_province_in_state_instance(state, s, [&](dcon::province_id p) { provs.push_back(p); });

			sys::merge_sort(provs.begin(), provs.end(), [&](dcon::province_id a, dcon::province_id b) {
				return text::produce_simple_string(state, state.world.province_get_name(a)) < text::produce_simple_string(state, state.world.province_get_name(b));
			});

			for(auto p : provs) {
				bool added_pop = false;
				bool province_is_open = popwindow::open_provs.contains(p.index());

				for(auto po : state.world.province_get_pop_location(p)) {
					if(pop_passes_filter(state, po.get_pop())) {
						if(!added_pop) {
							if(!added_header) {
								added_header = true;
								add_insert_state_row(state, s);
							}
							if(state_is_open) {
								add_insert_province_row(state, p);
							}
							added_pop = true;
						}
						if(state_is_open && province_is_open) {
							add_insert_pop_row(state, po.get_pop().id);
						}
					}
				}
			}
		}
	} else {
		add_insert_nation_row(state, state.local_player_nation);
		for(auto p : state.world.nation_get_province_ownership(state.local_player_nation)) {
			for(auto po : p.get_province().get_pop_location()) {
				if(pop_passes_filter(state, po.get_pop())) {
					add_insert_pop_row(state, po.get_pop().id);
				}
			}
		}
	}
// END
	impl_apply_sort(state);
	impl_change_page(state, page);
}
void demographicswindow_main_table_t::on_create(sys::state& state) noexcept {
// BEGIN main::table::create
// END
}
ui::message_result demographicswindow_main_show_filters_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN main::show_filters::lbutton_action
	main.filter_w->set_visible(state, true);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_show_filters_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_main_show_filters_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_main_show_filters_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_main_show_filters_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_main_show_filters_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::show_filters::update
// END
}
void demographicswindow_main_show_filters_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN main::show_filters::create
// END
}
ui::message_result demographicswindow_main_reset_filters_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN main::reset_filters::lbutton_action
	popwindow::show_colonial = true;
	popwindow::show_non_colonial = true;
	popwindow::excluded_cultures.clear();
	popwindow::excluded_religions.clear();
	popwindow::excluded_states.clear();
	popwindow::excluded_types.clear();
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_reset_filters_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_main_reset_filters_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_main_reset_filters_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_main_reset_filters_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_main_reset_filters_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::reset_filters::update
// END
}
void demographicswindow_main_reset_filters_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN main::reset_filters::create
// END
}
ui::message_result demographicswindow_main_only_pops_toggle_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN main::only_pops_toggle::lbutton_action
	popwindow::show_only_pops = !popwindow::show_only_pops;
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_only_pops_toggle_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_main_only_pops_toggle_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_main_only_pops_toggle_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_main_only_pops_toggle_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_main_only_pops_toggle_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::only_pops_toggle::update
	is_active = popwindow::show_only_pops;
// END
}
void demographicswindow_main_only_pops_toggle_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN main::only_pops_toggle::create
// END
}
ui::message_result demographicswindow_main_main_left_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN main::main_left::lbutton_action
	main.table->change_page(state, main.table->page - 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_main_left_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_main_main_left_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_main_main_left_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::main_left::update
// END
}
void demographicswindow_main_main_left_t::on_create(sys::state& state) noexcept {
// BEGIN main::main_left::create
// END
}
ui::message_result demographicswindow_main_main_right_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN main::main_right::lbutton_action
	main.table->change_page(state, main.table->page + 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_main_right_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_main_main_right_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_main_main_right_t::on_update(sys::state& state) noexcept {
	demographicswindow_main_t& main = *((demographicswindow_main_t*)(parent)); 
// BEGIN main::main_right::update
// END
}
void demographicswindow_main_main_right_t::on_create(sys::state& state) noexcept {
// BEGIN main::main_right::create
// END
}
ui::message_result demographicswindow_main_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	state.ui_state.drag_target = this;
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_main_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_main_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
}
void demographicswindow_main_t::on_update(sys::state& state) noexcept {
// BEGIN main::update
// END
}
void demographicswindow_main_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::main"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	texture_key = win_data.texture;
	auto name_key = state.lookup_key("demographicswindow::main");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "close_button") {
			auto cptr = std::make_unique<demographicswindow_main_close_button_t>();
			cptr->parent = this;
			close_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->tooltip_key = state.lookup_key(child_data.tooltip_text_key);
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "title") {
			auto cptr = std::make_unique<demographicswindow_main_title_t>();
			cptr->parent = this;
			title = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "main_page") {
			auto cptr = std::make_unique<demographicswindow_main_main_page_t>();
			cptr->parent = this;
			main_page = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "table") {
			auto cptr = std::make_unique<demographicswindow_main_table_t>();
			cptr->parent = this;
			table = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			int16_t col_sz_used = 0;
			demographicswindow_main_table_header_t::spacer_column_start = col_sz_used;
			demographicswindow_main_table_header_t::spacer_column_width = child_data.table_columns[0].width;
			col_sz_used += child_data.table_columns[0].width; 
			demographicswindow_main_table_header_t::location_text_color = child_data.table_columns[1].header_text_color;
			demographicswindow_main_table_header_t::location_text_key = state.lookup_key(child_data.table_columns[1].header_key);
			demographicswindow_main_table_row_t::location_default_text_color = child_data.table_columns[1].cell_text_color;
			demographicswindow_main_table_row_t::location_text_alignment = child_data.table_columns[1].text_alignment;
			demographicswindow_main_table_header_t::location_column_start = col_sz_used;
			demographicswindow_main_table_header_t::location_column_width = child_data.table_columns[1].width;
			col_sz_used += child_data.table_columns[1].width; 
			demographicswindow_main_table_header_t::size_text_color = child_data.table_columns[2].header_text_color;
			demographicswindow_main_table_header_t::size_text_key = state.lookup_key(child_data.table_columns[2].header_key);
			demographicswindow_main_table_row_t::size_default_text_color = child_data.table_columns[2].cell_text_color;
			demographicswindow_main_table_row_t::size_text_alignment = child_data.table_columns[2].text_alignment;
			demographicswindow_main_table_header_t::size_column_start = col_sz_used;
			demographicswindow_main_table_header_t::size_column_width = child_data.table_columns[2].width;
			col_sz_used += child_data.table_columns[2].width; 
			demographicswindow_main_table_header_t::culture_text_color = child_data.table_columns[3].header_text_color;
			demographicswindow_main_table_header_t::culture_text_key = state.lookup_key(child_data.table_columns[3].header_key);
			demographicswindow_main_table_row_t::culture_default_text_color = child_data.table_columns[3].cell_text_color;
			demographicswindow_main_table_row_t::culture_text_alignment = child_data.table_columns[3].text_alignment;
			demographicswindow_main_table_header_t::culture_column_start = col_sz_used;
			demographicswindow_main_table_header_t::culture_column_width = child_data.table_columns[3].width;
			col_sz_used += child_data.table_columns[3].width; 
			demographicswindow_main_table_header_t::job_text_color = child_data.table_columns[4].header_text_color;
			demographicswindow_main_table_header_t::job_text_key = state.lookup_key(child_data.table_columns[4].header_key);
			demographicswindow_main_table_row_t::job_default_text_color = child_data.table_columns[4].cell_text_color;
			demographicswindow_main_table_row_t::job_text_alignment = child_data.table_columns[4].text_alignment;
			demographicswindow_main_table_header_t::job_column_start = col_sz_used;
			demographicswindow_main_table_header_t::job_column_width = child_data.table_columns[4].width;
			col_sz_used += child_data.table_columns[4].width; 
			demographicswindow_main_table_header_t::religion_text_color = child_data.table_columns[5].header_text_color;
			demographicswindow_main_table_header_t::religion_text_key = state.lookup_key(child_data.table_columns[5].header_key);
			demographicswindow_main_table_row_t::religion_default_text_color = child_data.table_columns[5].cell_text_color;
			demographicswindow_main_table_row_t::religion_text_alignment = child_data.table_columns[5].text_alignment;
			demographicswindow_main_table_header_t::religion_column_start = col_sz_used;
			demographicswindow_main_table_header_t::religion_column_width = child_data.table_columns[5].width;
			col_sz_used += child_data.table_columns[5].width; 
			demographicswindow_main_table_header_t::ideology_text_color = child_data.table_columns[6].header_text_color;
			demographicswindow_main_table_header_t::ideology_text_key = state.lookup_key(child_data.table_columns[6].header_key);
			demographicswindow_main_table_row_t::ideology_default_text_color = child_data.table_columns[6].cell_text_color;
			demographicswindow_main_table_row_t::ideology_text_alignment = child_data.table_columns[6].text_alignment;
			demographicswindow_main_table_header_t::ideology_column_start = col_sz_used;
			demographicswindow_main_table_header_t::ideology_column_width = child_data.table_columns[6].width;
			col_sz_used += child_data.table_columns[6].width; 
			demographicswindow_main_table_header_t::issues_text_color = child_data.table_columns[7].header_text_color;
			demographicswindow_main_table_header_t::issues_text_key = state.lookup_key(child_data.table_columns[7].header_key);
			demographicswindow_main_table_row_t::issues_default_text_color = child_data.table_columns[7].cell_text_color;
			demographicswindow_main_table_row_t::issues_text_alignment = child_data.table_columns[7].text_alignment;
			demographicswindow_main_table_header_t::issues_column_start = col_sz_used;
			demographicswindow_main_table_header_t::issues_column_width = child_data.table_columns[7].width;
			col_sz_used += child_data.table_columns[7].width; 
			demographicswindow_main_table_header_t::militancy_text_color = child_data.table_columns[8].header_text_color;
			demographicswindow_main_table_header_t::militancy_text_key = state.lookup_key(child_data.table_columns[8].header_key);
			demographicswindow_main_table_row_t::militancy_default_text_color = child_data.table_columns[8].cell_text_color;
			demographicswindow_main_table_row_t::militancy_text_alignment = child_data.table_columns[8].text_alignment;
			demographicswindow_main_table_header_t::militancy_column_start = col_sz_used;
			demographicswindow_main_table_header_t::militancy_column_width = child_data.table_columns[8].width;
			col_sz_used += child_data.table_columns[8].width; 
			demographicswindow_main_table_header_t::consciousness_text_color = child_data.table_columns[9].header_text_color;
			demographicswindow_main_table_header_t::consciousness_text_key = state.lookup_key(child_data.table_columns[9].header_key);
			demographicswindow_main_table_row_t::consciousness_default_text_color = child_data.table_columns[9].cell_text_color;
			demographicswindow_main_table_row_t::consciousness_text_alignment = child_data.table_columns[9].text_alignment;
			demographicswindow_main_table_header_t::consciousness_column_start = col_sz_used;
			demographicswindow_main_table_header_t::consciousness_column_width = child_data.table_columns[9].width;
			col_sz_used += child_data.table_columns[9].width; 
			demographicswindow_main_table_header_t::employment_text_color = child_data.table_columns[10].header_text_color;
			demographicswindow_main_table_header_t::employment_text_key = state.lookup_key(child_data.table_columns[10].header_key);
			demographicswindow_main_table_row_t::employment_default_text_color = child_data.table_columns[10].cell_text_color;
			demographicswindow_main_table_row_t::employment_text_alignment = child_data.table_columns[10].text_alignment;
			demographicswindow_main_table_header_t::employment_column_start = col_sz_used;
			demographicswindow_main_table_header_t::employment_column_width = child_data.table_columns[10].width;
			col_sz_used += child_data.table_columns[10].width; 
			demographicswindow_main_table_header_t::literacy_text_color = child_data.table_columns[11].header_text_color;
			demographicswindow_main_table_header_t::literacy_text_key = state.lookup_key(child_data.table_columns[11].header_key);
			demographicswindow_main_table_row_t::literacy_default_text_color = child_data.table_columns[11].cell_text_color;
			demographicswindow_main_table_row_t::literacy_text_alignment = child_data.table_columns[11].text_alignment;
			demographicswindow_main_table_header_t::literacy_column_start = col_sz_used;
			demographicswindow_main_table_header_t::literacy_column_width = child_data.table_columns[11].width;
			col_sz_used += child_data.table_columns[11].width; 
			demographicswindow_main_table_header_t::money_text_color = child_data.table_columns[12].header_text_color;
			demographicswindow_main_table_header_t::money_text_key = state.lookup_key(child_data.table_columns[12].header_key);
			demographicswindow_main_table_row_t::money_default_text_color = child_data.table_columns[12].cell_text_color;
			demographicswindow_main_table_row_t::money_text_alignment = child_data.table_columns[12].text_alignment;
			demographicswindow_main_table_header_t::money_column_start = col_sz_used;
			demographicswindow_main_table_header_t::money_column_width = child_data.table_columns[12].width;
			col_sz_used += child_data.table_columns[12].width; 
			demographicswindow_main_table_header_t::needs_text_color = child_data.table_columns[13].header_text_color;
			demographicswindow_main_table_header_t::needs_text_key = state.lookup_key(child_data.table_columns[13].header_key);
			demographicswindow_main_table_row_t::needs_default_text_color = child_data.table_columns[13].cell_text_color;
			demographicswindow_main_table_row_t::needs_text_alignment = child_data.table_columns[13].text_alignment;
			demographicswindow_main_table_header_t::needs_column_start = col_sz_used;
			demographicswindow_main_table_header_t::needs_column_width = child_data.table_columns[13].width;
			col_sz_used += child_data.table_columns[13].width; 
			demographicswindow_main_table_header_t::rebels_text_color = child_data.table_columns[14].header_text_color;
			demographicswindow_main_table_header_t::rebels_text_key = state.lookup_key(child_data.table_columns[14].header_key);
			demographicswindow_main_table_row_t::rebels_default_text_color = child_data.table_columns[14].cell_text_color;
			demographicswindow_main_table_row_t::rebels_text_alignment = child_data.table_columns[14].text_alignment;
			demographicswindow_main_table_header_t::rebels_column_start = col_sz_used;
			demographicswindow_main_table_header_t::rebels_column_width = child_data.table_columns[14].width;
			col_sz_used += child_data.table_columns[14].width; 
			demographicswindow_main_table_header_t::ascending_icon_key = child_data.ascending_sort_icon;
			demographicswindow_main_table_header_t::descending_icon_key = child_data.descending_sort_icon;
			demographicswindow_main_table_row_t::row_texture_key = child_data.row_background_a;
			demographicswindow_main_table_row_t::alt_row_texture_key = child_data.row_background_b;
			demographicswindow_main_table_t::row_height = child_data.row_height;
			demographicswindow_main_table_t::table_divider_color = child_data.table_divider_color;
			demographicswindow_main_table_t::table_highlight_color = child_data.table_highlight_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "show_filters") {
			auto cptr = std::make_unique<demographicswindow_main_show_filters_t>();
			cptr->parent = this;
			show_filters = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "reset_filters") {
			auto cptr = std::make_unique<demographicswindow_main_reset_filters_t>();
			cptr->parent = this;
			reset_filters = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "only_pops_toggle") {
			auto cptr = std::make_unique<demographicswindow_main_only_pops_toggle_t>();
			cptr->parent = this;
			only_pops_toggle = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "main_left") {
			auto cptr = std::make_unique<demographicswindow_main_main_left_t>();
			cptr->parent = this;
			main_left = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "main_right") {
			auto cptr = std::make_unique<demographicswindow_main_main_right_t>();
			cptr->parent = this;
			main_right = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN main::create
	auto fw = make_demographicswindow_filters_window(state);
	filter_w = (demographicswindow_filters_window_t*)(fw.get());
	this->add_child_to_front(std::move(fw));
	filter_w->set_visible(state, false);

	{
		auto ptr = ui::make_element_by_type<ui::national_focus_window>(state, "state_focus_window");
		focus_w = (ui::national_focus_window*)(ptr.get());
		add_child_to_front(std::move(ptr));
		focus_w->set_visible(state, false);
	}
	{
		auto win7 = ui::make_element_by_type<ui::pop_details_window>(state, state.ui_state.defs_by_name.find(state.lookup_key("pop_details_win"))->second.definition);
		details_w = (ui::pop_details_window*)(win7.get());
		add_child_to_front(std::move(win7));
		details_w->set_visible(state, false);
	}
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_main(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_main_t>();
	ptr->on_create(state);
	return ptr;
}
void demographicswindow_nation_row_location_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_nation_row_location_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_nation_row_location_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_nation_row_location_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::location::update
	set_text(state, text::get_name_as_string(state, nation_row.content));
// END
}
void demographicswindow_nation_row_location_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::location::create
// END
}
void demographicswindow_nation_row_size_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_nation_row_size_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_nation_row_size_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_nation_row_size_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::size::update
	float total = 0.0f;
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				total += o.get_pop().get_size();
			}
		}
	}
	set_text(state, text::prettify(int64_t(total)));
// END
}
void demographicswindow_nation_row_size_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::size::create
// END
}
ui::message_result demographicswindow_nation_row_size_trend_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_size_trend_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_size_trend_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::size_trend::tooltip
	auto box = text::open_layout_box(contents);
	text::localised_format_box(state, contents, box, "pop_growth_1");
	auto result = demographics::get_monthly_pop_increase(state, nation_row.content);

	if(result >= 0) {
		text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
		text::add_to_layout_box(state, contents, box, int64_t(result), text::text_color::green);
	} else {
		text::add_to_layout_box(state, contents, box, int64_t(result), text::text_color::red);
	}
	text::close_layout_box(contents, box);
// END
}
void demographicswindow_nation_row_size_trend_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_nation_row_size_trend_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::size_trend::update
	auto result = demographics::get_monthly_pop_increase(state, nation_row.content);
	if(result > 0) {
		frame = 0;
	} else if(result < 0) {
		frame = 2;
	} else {
		frame = 1;
	}
// END
}
void demographicswindow_nation_row_size_trend_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN nation_row::size_trend::create
// END
}
ui::message_result demographicswindow_nation_row_culture_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_culture_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_culture_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_nation_row_culture_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN nation_row::culture::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.culture_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_nation_row_culture_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_nation_row_culture_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::culture::update
	auto cultures = state.world.culture_make_vectorizable_float_buffer();
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_culture();
				if(c)
					cultures.get(c) += o.get_pop().get_size();
			}
		}
	}
	graph_content.clear();
	for(auto c : state.world.in_culture) {
		if(cultures.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), cultures.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_nation_row_culture_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::culture::create
// END
}
ui::message_result demographicswindow_nation_row_job_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_job_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_job_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_nation_row_job_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN nation_row::job::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.pop_type_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_nation_row_job_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_nation_row_job_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::job::update
	auto jobs = state.world.pop_type_make_vectorizable_float_buffer();
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_poptype();
				if(c)
					jobs.get(c) += o.get_pop().get_size();
			}
		}
	}
	graph_content.clear();
	for(auto c : state.world.in_pop_type) {
		if(jobs.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), jobs.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_nation_row_job_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::job::create
// END
}
ui::message_result demographicswindow_nation_row_religion_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_religion_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_religion_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_nation_row_religion_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN nation_row::religion::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.religion_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_nation_row_religion_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_nation_row_religion_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::religion::update
	auto religions = state.world.religion_make_vectorizable_float_buffer();
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_religion();
				if(c)
					religions.get(c) += o.get_pop().get_size();
			}
		}
	}
	graph_content.clear();
	for(auto c : state.world.in_religion) {
		if(religions.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), religions.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_nation_row_religion_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::religion::create
// END
}
ui::message_result demographicswindow_nation_row_ideology_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_ideology_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_ideology_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_nation_row_ideology_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN nation_row::ideology::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.ideology_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_nation_row_ideology_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_nation_row_ideology_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::ideology::update
	auto ideologies = state.world.ideology_make_vectorizable_float_buffer();
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto sz = o.get_pop().get_size();
				for(auto i : state.world.in_ideology) {
					ideologies.get(i) = ideologies.get(i) + sz * pop_demographics::from_pu16(o.get_pop().get_udemographics(pop_demographics::to_key(state, i)));
				}
			}
		}
	}
	graph_content.clear();
	for(auto c : state.world.in_ideology) {
		if(ideologies.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), ideologies.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_nation_row_ideology_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::ideology::create
// END
}
ui::message_result demographicswindow_nation_row_issues_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_issues_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_issues_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_nation_row_issues_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN nation_row::issues::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.issue_get_name(state.world.issue_option_get_parent_issue(selected_key)));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, state.world.issue_option_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_nation_row_issues_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_nation_row_issues_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::issues::update
	auto issues = state.world.issue_option_make_vectorizable_float_buffer();
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto sz = o.get_pop().get_size();
				for(auto i : state.world.in_issue_option) {
					issues.get(i) = issues.get(i) + sz * pop_demographics::from_pu16(o.get_pop().get_udemographics(pop_demographics::to_key(state, i)));
				}
			}
		}
	}
	graph_content.clear();
	for(auto c : state.world.in_issue_option) {
		if(issues.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(ogl::get_ui_color(state, c.id)), issues.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_nation_row_issues_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::issues::create
// END
}
void demographicswindow_nation_row_militancy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_nation_row_militancy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_nation_row_militancy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_nation_row_militancy_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::militancy::update
	float total = 0.0f;
	float sz = 0.0f;
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::from_pmc(o.get_pop().get_umilitancy()) * o.get_pop().get_size();
			}
		}
	}
	set_text(state, text::format_float(sz > 0 ? total / sz : 0.0f, 1));
// END
}
void demographicswindow_nation_row_militancy_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::militancy::create
// END
}
void demographicswindow_nation_row_consciousness_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_nation_row_consciousness_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_nation_row_consciousness_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_nation_row_consciousness_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::consciousness::update
	float total = 0.0f;
	float sz = 0.0f;
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::from_pmc(o.get_pop().get_uconsciousness()) * o.get_pop().get_size();
			}
		}
	}
	set_text(state, text::format_float(sz > 0 ? total / sz : 0.0f, 1));
// END
}
void demographicswindow_nation_row_consciousness_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::consciousness::create
// END
}
void demographicswindow_nation_row_employment_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_nation_row_employment_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_nation_row_employment_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_nation_row_employment_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::employment::update
	float total = 0.0f;
	float sz = 0.0f;
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				if(o.get_pop().get_poptype().get_has_unemployment()) {
					sz += o.get_pop().get_size();
					total += pop_demographics::get_employment(state, o.get_pop());
				} else {
					sz += o.get_pop().get_size();
					total += o.get_pop().get_size();
				}
			}
		}
	}
	set_text(state, text::format_percentage(sz > 0 ? total / sz : 0.0f, 0));
// END
}
void demographicswindow_nation_row_employment_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::employment::create
// END
}
void demographicswindow_nation_row_literacy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_nation_row_literacy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_nation_row_literacy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_nation_row_literacy_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::literacy::update
	float total = 0.0f;
	float sz = 0.0f;
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::get_literacy(state, o.get_pop()) * o.get_pop().get_size();
			}
		}
	}
	set_text(state, text::format_percentage(sz > 0 ? total / sz : 0.0f, 0));
// END
}
void demographicswindow_nation_row_literacy_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::literacy::create
// END
}
void demographicswindow_nation_row_money_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_nation_row_money_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_nation_row_money_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_nation_row_money_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::money::update
	float total = 0.0f;
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				total += o.get_pop().get_savings();
			}
		}
	}
	set_text(state, text::prettify_currency(total));
// END
}
void demographicswindow_nation_row_money_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::money::create
// END
}
ui::message_result demographicswindow_nation_row_needs_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_needs_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_needs_t::update_chart(sys::state& state) {
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 99; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 99; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(99)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_nation_row_needs_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN nation_row::needs::tooltip
		float total = 0.0f;
		auto box = text::open_layout_box(contents);
		if(temp_index == 0 || temp_index == 1) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("life_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[0].amount });
		} else if(temp_index == 2 || temp_index == 3) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("everyday_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[2].amount });
		} else if(temp_index == 4 || temp_index == 5) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("luxury_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[4].amount });
		}
		
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_nation_row_needs_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_nation_row_needs_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::needs::update
	float lntotal = 0.0f;
	float entotal = 0.0f;
	float lxtotal = 0.0f;
	float sz = 0.0f;
	for(auto p : state.world.nation_get_province_ownership(nation_row.content)) {
		for(auto o : p.get_province().get_pop_location()) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				lntotal += pop_demographics::get_life_needs(state, o.get_pop()) * o.get_pop().get_size();
				entotal += pop_demographics::get_everyday_needs(state, o.get_pop()) * o.get_pop().get_size();
				lxtotal += pop_demographics::get_luxury_needs(state, o.get_pop()) * o.get_pop().get_size();
			}
		}
	}

	graph_content.clear();
	graph_content.emplace_back(graph_entry{ 0, ogl::color3f{ 130.0f / 255.0f, 162.0f / 255.0f, 217.0f / 255.0f }, sz > 0.0f ? lntotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 1, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - lntotal / sz : 1.0f });
	graph_content.emplace_back(graph_entry{ 2, ogl::color3f{ 210.0f / 255.0f, 140.0f / 255.0f, 37.0f / 255.0f }, sz > 0.0f ? entotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 3, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - entotal / sz : 1.0f });
	graph_content.emplace_back(graph_entry{ 4, ogl::color3f{ 157.0f / 255.0f, 66.0f / 255.0f, 62.0f / 255.0f }, sz > 0.0f ? lxtotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 5, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - lxtotal / sz : 1.0f });
	update_chart(state);
// END
}
void demographicswindow_nation_row_needs_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::needs::create
// END
}
ui::message_result demographicswindow_nation_row_frames_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_nation_row_frames_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_nation_row_frames_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_nation_row_frames_t::on_update(sys::state& state) noexcept {
	demographicswindow_nation_row_t& nation_row = *((demographicswindow_nation_row_t*)(parent)); 
// BEGIN nation_row::frames::update
// END
}
void demographicswindow_nation_row_frames_t::on_create(sys::state& state) noexcept {
// BEGIN nation_row::frames::create
// END
}
ui::message_result demographicswindow_nation_row_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_nation_row_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_nation_row_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	auto under_mouse = [&](){auto p = state.ui_state.under_mouse; while(p){ if(p == this) return true; p = p->parent; } return false;}();
	int32_t rel_mouse_x = int32_t(state.mouse_x_position / state.user_settings.ui_scale) - ui::get_absolute_location(state, *this).x;
	if(under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x), float(y), float(base_data.size.x), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_spacer = rel_mouse_x >= demographicswindow_main_table_header_t::spacer_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::spacer_column_start + demographicswindow_main_table_header_t::spacer_column_width);
	bool col_um_location = rel_mouse_x >= demographicswindow_main_table_header_t::location_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::location_column_start + demographicswindow_main_table_header_t::location_column_width);
	if(col_um_location && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::location_column_start), float(y), float(demographicswindow_main_table_header_t::location_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_size = rel_mouse_x >= demographicswindow_main_table_header_t::size_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::size_column_start + demographicswindow_main_table_header_t::size_column_width);
	if(col_um_size && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::size_column_start), float(y), float(demographicswindow_main_table_header_t::size_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_culture = rel_mouse_x >= demographicswindow_main_table_header_t::culture_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::culture_column_start + demographicswindow_main_table_header_t::culture_column_width);
	if(col_um_culture && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::culture_column_start), float(y), float(demographicswindow_main_table_header_t::culture_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_job = rel_mouse_x >= demographicswindow_main_table_header_t::job_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::job_column_start + demographicswindow_main_table_header_t::job_column_width);
	if(col_um_job && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::job_column_start), float(y), float(demographicswindow_main_table_header_t::job_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_religion = rel_mouse_x >= demographicswindow_main_table_header_t::religion_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::religion_column_start + demographicswindow_main_table_header_t::religion_column_width);
	if(col_um_religion && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::religion_column_start), float(y), float(demographicswindow_main_table_header_t::religion_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_ideology = rel_mouse_x >= demographicswindow_main_table_header_t::ideology_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::ideology_column_start + demographicswindow_main_table_header_t::ideology_column_width);
	if(col_um_ideology && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::ideology_column_start), float(y), float(demographicswindow_main_table_header_t::ideology_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_issues = rel_mouse_x >= demographicswindow_main_table_header_t::issues_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::issues_column_start + demographicswindow_main_table_header_t::issues_column_width);
	if(col_um_issues && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::issues_column_start), float(y), float(demographicswindow_main_table_header_t::issues_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_militancy = rel_mouse_x >= demographicswindow_main_table_header_t::militancy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::militancy_column_start + demographicswindow_main_table_header_t::militancy_column_width);
	if(col_um_militancy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::militancy_column_start), float(y), float(demographicswindow_main_table_header_t::militancy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_consciousness = rel_mouse_x >= demographicswindow_main_table_header_t::consciousness_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::consciousness_column_start + demographicswindow_main_table_header_t::consciousness_column_width);
	if(col_um_consciousness && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::consciousness_column_start), float(y), float(demographicswindow_main_table_header_t::consciousness_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_employment = rel_mouse_x >= demographicswindow_main_table_header_t::employment_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::employment_column_start + demographicswindow_main_table_header_t::employment_column_width);
	if(col_um_employment && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::employment_column_start), float(y), float(demographicswindow_main_table_header_t::employment_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_literacy = rel_mouse_x >= demographicswindow_main_table_header_t::literacy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::literacy_column_start + demographicswindow_main_table_header_t::literacy_column_width);
	if(col_um_literacy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::literacy_column_start), float(y), float(demographicswindow_main_table_header_t::literacy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_money = rel_mouse_x >= demographicswindow_main_table_header_t::money_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::money_column_start + demographicswindow_main_table_header_t::money_column_width);
	if(col_um_money && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::money_column_start), float(y), float(demographicswindow_main_table_header_t::money_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_needs = rel_mouse_x >= demographicswindow_main_table_header_t::needs_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::needs_column_start + demographicswindow_main_table_header_t::needs_column_width);
	if(col_um_needs && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::needs_column_start), float(y), float(demographicswindow_main_table_header_t::needs_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_rebels = rel_mouse_x >= demographicswindow_main_table_header_t::rebels_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::rebels_column_start + demographicswindow_main_table_header_t::rebels_column_width);
	if(col_um_rebels && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::rebels_column_start), float(y), float(demographicswindow_main_table_header_t::rebels_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
}
void demographicswindow_nation_row_t::on_update(sys::state& state) noexcept {
// BEGIN nation_row::update
// END
}
void demographicswindow_nation_row_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::nation_row"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	texture_key = win_data.texture;
	alt_texture_key = win_data.alt_texture;
	auto name_key = state.lookup_key("demographicswindow::nation_row");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "location") {
			auto cptr = std::make_unique<demographicswindow_nation_row_location_t>();
			cptr->parent = this;
			location = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size") {
			auto cptr = std::make_unique<demographicswindow_nation_row_size_t>();
			cptr->parent = this;
			size = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size_trend") {
			auto cptr = std::make_unique<demographicswindow_nation_row_size_trend_t>();
			cptr->parent = this;
			size_trend = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture") {
			auto cptr = std::make_unique<demographicswindow_nation_row_culture_t>();
			cptr->parent = this;
			culture = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job") {
			auto cptr = std::make_unique<demographicswindow_nation_row_job_t>();
			cptr->parent = this;
			job = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion") {
			auto cptr = std::make_unique<demographicswindow_nation_row_religion_t>();
			cptr->parent = this;
			religion = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "ideology") {
			auto cptr = std::make_unique<demographicswindow_nation_row_ideology_t>();
			cptr->parent = this;
			ideology = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "issues") {
			auto cptr = std::make_unique<demographicswindow_nation_row_issues_t>();
			cptr->parent = this;
			issues = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "militancy") {
			auto cptr = std::make_unique<demographicswindow_nation_row_militancy_t>();
			cptr->parent = this;
			militancy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "consciousness") {
			auto cptr = std::make_unique<demographicswindow_nation_row_consciousness_t>();
			cptr->parent = this;
			consciousness = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "employment") {
			auto cptr = std::make_unique<demographicswindow_nation_row_employment_t>();
			cptr->parent = this;
			employment = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "literacy") {
			auto cptr = std::make_unique<demographicswindow_nation_row_literacy_t>();
			cptr->parent = this;
			literacy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "money") {
			auto cptr = std::make_unique<demographicswindow_nation_row_money_t>();
			cptr->parent = this;
			money = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "needs") {
			auto cptr = std::make_unique<demographicswindow_nation_row_needs_t>();
			cptr->parent = this;
			needs = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "frames") {
			auto cptr = std::make_unique<demographicswindow_nation_row_frames_t>();
			cptr->parent = this;
			frames = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN nation_row::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_nation_row(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_nation_row_t>();
	ptr->on_create(state);
	return ptr;
}
ui::message_result demographicswindow_state_row_folder_icon_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN state_row::folder_icon::lbutton_action
	if(popwindow::open_states.contains(state_row.content.index()))
		popwindow::open_states.erase(state_row.content.index());
	else
		popwindow::open_states.insert(state_row.content.index());
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_state_row_folder_icon_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_state_row_folder_icon_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_state_row_folder_icon_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::folder_icon::update
	is_active = popwindow::open_states.contains(state_row.content.index());
// END
}
void demographicswindow_state_row_folder_icon_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::folder_icon::create
// END
}
void demographicswindow_state_row_location_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_state_row_location_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_state_row_location_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_state_row_location_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::location::update
	set_text(state, text::get_short_state_name(state, state_row.content));
// END
}
void demographicswindow_state_row_location_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::location::create
// END
}
void demographicswindow_state_row_size_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_state_row_size_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_state_row_size_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_state_row_size_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::size::update
	float total = 0.0f;
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				total += o.get_pop().get_size();
			}
		}
	});
	set_text(state, text::prettify(int64_t(total)));
// END
}
void demographicswindow_state_row_size_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::size::create
// END
}
ui::message_result demographicswindow_state_row_size_trend_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_size_trend_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_size_trend_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::size_trend::tooltip
	auto box = text::open_layout_box(contents);
	text::localised_format_box(state, contents, box, "pop_growth_1");
	auto result = demographics::get_monthly_pop_increase(state, state_row.content);

	if(result >= 0) {
		text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
		text::add_to_layout_box(state, contents, box, int64_t(result), text::text_color::green);
	} else {
		text::add_to_layout_box(state, contents, box, int64_t(result), text::text_color::red);
	}
	text::close_layout_box(contents, box);
// END
}
void demographicswindow_state_row_size_trend_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_state_row_size_trend_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::size_trend::update
	auto result = demographics::get_monthly_pop_increase(state, state_row.content);
	if(result > 0) {
		frame = 0;
	} else if(result < 0) {
		frame = 2;
	} else {
		frame = 1;
	}
// END
}
void demographicswindow_state_row_size_trend_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN state_row::size_trend::create
// END
}
ui::message_result demographicswindow_state_row_culture_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_culture_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_culture_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_state_row_culture_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN state_row::culture::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.culture_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_state_row_culture_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_state_row_culture_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::culture::update
	auto cultures = state.world.culture_make_vectorizable_float_buffer();
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_culture();
				if(c)
					cultures.get(c) += o.get_pop().get_size();
			}
		}
	});
	graph_content.clear();
	for(auto c : state.world.in_culture) {
		if(cultures.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), cultures.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_state_row_culture_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::culture::create
// END
}
ui::message_result demographicswindow_state_row_job_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_job_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_job_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_state_row_job_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN state_row::job::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.pop_type_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_state_row_job_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_state_row_job_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::job::update
	auto jobs = state.world.pop_type_make_vectorizable_float_buffer();
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_poptype();
				if(c)
					jobs.get(c) += o.get_pop().get_size();
			}
		}
	});
	graph_content.clear();
	for(auto c : state.world.in_pop_type) {
		if(jobs.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), jobs.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_state_row_job_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::job::create
// END
}
ui::message_result demographicswindow_state_row_religion_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_religion_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_religion_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_state_row_religion_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN state_row::religion::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.religion_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_state_row_religion_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_state_row_religion_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::religion::update
	auto religions = state.world.religion_make_vectorizable_float_buffer();
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_religion();
				if(c)
					religions.get(c) += o.get_pop().get_size();
			}
		}
	});
	graph_content.clear();
	for(auto c : state.world.in_religion) {
		if(religions.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), religions.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_state_row_religion_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::religion::create
// END
}
ui::message_result demographicswindow_state_row_ideology_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_ideology_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_ideology_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_state_row_ideology_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN state_row::ideology::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.ideology_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_state_row_ideology_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_state_row_ideology_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::ideology::update
	auto ideologies = state.world.ideology_make_vectorizable_float_buffer();
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto sz = o.get_pop().get_size();
				for(auto i : state.world.in_ideology) {
					ideologies.get(i) = ideologies.get(i) + sz * pop_demographics::from_pu16(o.get_pop().get_udemographics(pop_demographics::to_key(state, i)));
				}
			}
		}
	});
	graph_content.clear();
	for(auto c : state.world.in_ideology) {
		if(ideologies.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), ideologies.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_state_row_ideology_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::ideology::create
// END
}
ui::message_result demographicswindow_state_row_issues_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_issues_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_issues_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_state_row_issues_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN state_row::issues::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.issue_get_name(state.world.issue_option_get_parent_issue(selected_key)));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, state.world.issue_option_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_state_row_issues_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_state_row_issues_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::issues::update
	auto issues = state.world.issue_option_make_vectorizable_float_buffer();
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto sz = o.get_pop().get_size();
				for(auto i : state.world.in_issue_option) {
					issues.get(i) = issues.get(i) + sz * pop_demographics::from_pu16(o.get_pop().get_udemographics(pop_demographics::to_key(state, i)));
				}
			}
		}
	});
	graph_content.clear();
	for(auto c : state.world.in_issue_option) {
		if(issues.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(ogl::get_ui_color(state, c.id)), issues.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_state_row_issues_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::issues::create
// END
}
void demographicswindow_state_row_militancy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_state_row_militancy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_state_row_militancy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_state_row_militancy_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::militancy::update
	float total = 0.0f;
	float sz = 0.0f;
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::from_pmc(o.get_pop().get_umilitancy()) * o.get_pop().get_size();
			}
		}
	});
	set_text(state, text::format_float(sz > 0 ? total / sz : 0.0f, 1));
// END
}
void demographicswindow_state_row_militancy_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::militancy::create
// END
}
void demographicswindow_state_row_consciousness_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_state_row_consciousness_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_state_row_consciousness_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_state_row_consciousness_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::consciousness::update
	float total = 0.0f;
	float sz = 0.0f;
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::from_pmc(o.get_pop().get_uconsciousness()) * o.get_pop().get_size();
			}
		}
	});
	set_text(state, text::format_float(sz > 0 ? total / sz : 0.0f, 1));
// END
}
void demographicswindow_state_row_consciousness_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::consciousness::create
// END
}
void demographicswindow_state_row_employment_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_state_row_employment_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_state_row_employment_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_state_row_employment_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::employment::update
	float total = 0.0f;
	float sz = 0.0f;
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				if(o.get_pop().get_poptype().get_has_unemployment()) {
					sz += o.get_pop().get_size();
					total += pop_demographics::get_employment(state, o.get_pop());
				} else {
					sz += o.get_pop().get_size();
					total += o.get_pop().get_size();
				}
			}
		}
	});
	set_text(state, text::format_percentage(sz > 0 ? total / sz : 0.0f, 0));
// END
}
void demographicswindow_state_row_employment_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::employment::create
// END
}
void demographicswindow_state_row_literacy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_state_row_literacy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_state_row_literacy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_state_row_literacy_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::literacy::update
	float total = 0.0f;
	float sz = 0.0f;
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::get_literacy(state, o.get_pop()) * o.get_pop().get_size();
			}
		}
	});
	set_text(state, text::format_percentage(sz > 0 ? total / sz : 0.0f, 0));
// END
}
void demographicswindow_state_row_literacy_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::literacy::create
// END
}
void demographicswindow_state_row_money_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_state_row_money_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_state_row_money_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_state_row_money_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::money::update
	float total = 0.0f;
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				total += o.get_pop().get_savings();
			}
		}
	});
	set_text(state, text::prettify_currency(total));
// END
}
void demographicswindow_state_row_money_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::money::create
// END
}
ui::message_result demographicswindow_state_row_needs_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_needs_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_needs_t::update_chart(sys::state& state) {
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 99; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 99; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(99)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_state_row_needs_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN state_row::needs::tooltip
		float total = 0.0f;
		auto box = text::open_layout_box(contents);
		if(temp_index == 0 || temp_index == 1) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("life_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[0].amount });
		} else if(temp_index == 2 || temp_index == 3) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("everyday_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[2].amount });
		} else if(temp_index == 4 || temp_index == 5) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("luxury_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[4].amount });
		}

		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_state_row_needs_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_state_row_needs_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::needs::update
	float lntotal = 0.0f;
	float entotal = 0.0f;
	float lxtotal = 0.0f;
	float sz = 0.0f;
	province::for_each_province_in_state_instance(state, state_row.content, [&](dcon::province_id p) {
		for(auto o : state.world.province_get_pop_location(p)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				lntotal += pop_demographics::get_life_needs(state, o.get_pop()) * o.get_pop().get_size();
				entotal += pop_demographics::get_everyday_needs(state, o.get_pop()) * o.get_pop().get_size();
				lxtotal += pop_demographics::get_luxury_needs(state, o.get_pop()) * o.get_pop().get_size();
			}
		}
	});

	graph_content.clear();
	graph_content.emplace_back(graph_entry{ 0, ogl::color3f{ 130.0f / 255.0f, 162.0f / 255.0f, 217.0f / 255.0f }, sz > 0.0f ? lntotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 1, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - lntotal / sz : 1.0f });
	graph_content.emplace_back(graph_entry{ 2, ogl::color3f{ 210.0f / 255.0f, 140.0f / 255.0f, 37.0f / 255.0f }, sz > 0.0f ? entotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 3, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - entotal / sz : 1.0f });
	graph_content.emplace_back(graph_entry{ 4, ogl::color3f{ 157.0f / 255.0f, 66.0f / 255.0f, 62.0f / 255.0f }, sz > 0.0f ? lxtotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 5, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - lxtotal / sz : 1.0f });
	update_chart(state);
// END
}
void demographicswindow_state_row_needs_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::needs::create
// END
}
ui::message_result demographicswindow_state_row_frames_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_state_row_frames_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_state_row_frames_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_state_row_frames_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::frames::update
// END
}
void demographicswindow_state_row_frames_t::on_create(sys::state& state) noexcept {
// BEGIN state_row::frames::create
// END
}
ui::message_result demographicswindow_state_row_focus_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	if(disabled) return ui::message_result::consumed;
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN state_row::focus_button::lbutton_action
	auto fwindow_ptr = (ui::national_focus_window**)(parent->parent->parent->get_by_name(state, "focus_w"));
	assert(fwindow_ptr);
	(*fwindow_ptr)->provided = state_row.content;
	if(!(*fwindow_ptr)->is_visible())
		(*fwindow_ptr)->set_visible(state, true);
	else
		(*fwindow_ptr)->impl_on_update(state);
	(*fwindow_ptr)->base_data.position = base_data.position;
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_state_row_focus_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	if(disabled) return ui::message_result::consumed;
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN state_row::focus_button::rbutton_action
	command::set_national_focus(state, state.local_player_nation, state_row.content, dcon::national_focus_id{});
// END
	return ui::message_result::consumed;
}
void demographicswindow_state_row_focus_button_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::focus_button::tooltip
	auto box = text::open_layout_box(contents, 0);

	auto sid = state_row.content;
	auto fat_si = dcon::fatten(state.world, sid);
	text::add_to_layout_box(state, contents, box, sid);
	text::add_line_break_to_layout_box(state, contents, box);
	auto content = state.world.state_instance_get_owner_focus(sid);
	if(bool(content)) {
		auto fat_nf = dcon::fatten(state.world, content);
		text::add_to_layout_box(state, contents, box, state.world.national_focus_get_name(content), text::substitution_map{});
		text::add_line_break_to_layout_box(state, contents, box);
		auto color = text::text_color::white;
		if(fat_nf.get_promotion_type()) {
			//Is the NF not optimal? Recolor it
			if(fat_nf.get_promotion_type() == state.culture_definitions.clergy) {
				if((fat_si.get_demographics(demographics::to_key(state, fat_nf.get_promotion_type())) / fat_si.get_demographics(demographics::total)) > state.defines.max_clergy_for_literacy) {
					color = text::text_color::red;
				}
			} else if(fat_nf.get_promotion_type() == state.culture_definitions.bureaucrat) {
				if(province::state_admin_efficiency(state, fat_si.id) > state.defines.max_bureaucracy_percentage) {
					color = text::text_color::red;
				}
			}
			auto full_str = text::format_percentage(fat_si.get_demographics(demographics::to_key(state, fat_nf.get_promotion_type())) / fat_si.get_demographics(demographics::total));
			text::add_to_layout_box(state, contents, box, std::string_view(full_str), color);
		}
	}
	text::close_layout_box(contents, box);
	if(auto mid = state.world.national_focus_get_modifier(content);  mid) {
		ui::modifier_description(state, contents, mid, 15);
	}
	text::add_line(state, contents, "alice_nf_controls");
// END
}
void demographicswindow_state_row_focus_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, disabled, true), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, disabled, true), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, disabled, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_state_row_focus_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_state_row_t& state_row = *((demographicswindow_state_row_t*)(parent)); 
// BEGIN state_row::focus_button::update
	auto content = state_row.content;
	disabled = true;
	state.world.for_each_national_focus([&](dcon::national_focus_id nfid) {
		disabled = command::can_set_national_focus(state, state.local_player_nation, content, nfid) ? false : disabled;
	});
	frame = bool(state.world.state_instance_get_owner_focus(content).id) ? state.world.state_instance_get_owner_focus(content).get_icon() - 1 : 0;
// END
}
void demographicswindow_state_row_focus_button_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN state_row::focus_button::create
// END
}
ui::message_result demographicswindow_state_row_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_state_row_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_state_row_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	auto under_mouse = [&](){auto p = state.ui_state.under_mouse; while(p){ if(p == this) return true; p = p->parent; } return false;}();
	int32_t rel_mouse_x = int32_t(state.mouse_x_position / state.user_settings.ui_scale) - ui::get_absolute_location(state, *this).x;
	if(under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x), float(y), float(base_data.size.x), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_spacer = rel_mouse_x >= demographicswindow_main_table_header_t::spacer_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::spacer_column_start + demographicswindow_main_table_header_t::spacer_column_width);
	bool col_um_location = rel_mouse_x >= demographicswindow_main_table_header_t::location_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::location_column_start + demographicswindow_main_table_header_t::location_column_width);
	if(col_um_location && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::location_column_start), float(y), float(demographicswindow_main_table_header_t::location_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_size = rel_mouse_x >= demographicswindow_main_table_header_t::size_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::size_column_start + demographicswindow_main_table_header_t::size_column_width);
	if(col_um_size && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::size_column_start), float(y), float(demographicswindow_main_table_header_t::size_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_culture = rel_mouse_x >= demographicswindow_main_table_header_t::culture_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::culture_column_start + demographicswindow_main_table_header_t::culture_column_width);
	if(col_um_culture && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::culture_column_start), float(y), float(demographicswindow_main_table_header_t::culture_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_job = rel_mouse_x >= demographicswindow_main_table_header_t::job_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::job_column_start + demographicswindow_main_table_header_t::job_column_width);
	if(col_um_job && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::job_column_start), float(y), float(demographicswindow_main_table_header_t::job_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_religion = rel_mouse_x >= demographicswindow_main_table_header_t::religion_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::religion_column_start + demographicswindow_main_table_header_t::religion_column_width);
	if(col_um_religion && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::religion_column_start), float(y), float(demographicswindow_main_table_header_t::religion_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_ideology = rel_mouse_x >= demographicswindow_main_table_header_t::ideology_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::ideology_column_start + demographicswindow_main_table_header_t::ideology_column_width);
	if(col_um_ideology && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::ideology_column_start), float(y), float(demographicswindow_main_table_header_t::ideology_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_issues = rel_mouse_x >= demographicswindow_main_table_header_t::issues_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::issues_column_start + demographicswindow_main_table_header_t::issues_column_width);
	if(col_um_issues && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::issues_column_start), float(y), float(demographicswindow_main_table_header_t::issues_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_militancy = rel_mouse_x >= demographicswindow_main_table_header_t::militancy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::militancy_column_start + demographicswindow_main_table_header_t::militancy_column_width);
	if(col_um_militancy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::militancy_column_start), float(y), float(demographicswindow_main_table_header_t::militancy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_consciousness = rel_mouse_x >= demographicswindow_main_table_header_t::consciousness_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::consciousness_column_start + demographicswindow_main_table_header_t::consciousness_column_width);
	if(col_um_consciousness && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::consciousness_column_start), float(y), float(demographicswindow_main_table_header_t::consciousness_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_employment = rel_mouse_x >= demographicswindow_main_table_header_t::employment_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::employment_column_start + demographicswindow_main_table_header_t::employment_column_width);
	if(col_um_employment && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::employment_column_start), float(y), float(demographicswindow_main_table_header_t::employment_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_literacy = rel_mouse_x >= demographicswindow_main_table_header_t::literacy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::literacy_column_start + demographicswindow_main_table_header_t::literacy_column_width);
	if(col_um_literacy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::literacy_column_start), float(y), float(demographicswindow_main_table_header_t::literacy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_money = rel_mouse_x >= demographicswindow_main_table_header_t::money_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::money_column_start + demographicswindow_main_table_header_t::money_column_width);
	if(col_um_money && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::money_column_start), float(y), float(demographicswindow_main_table_header_t::money_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_needs = rel_mouse_x >= demographicswindow_main_table_header_t::needs_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::needs_column_start + demographicswindow_main_table_header_t::needs_column_width);
	if(col_um_needs && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::needs_column_start), float(y), float(demographicswindow_main_table_header_t::needs_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_rebels = rel_mouse_x >= demographicswindow_main_table_header_t::rebels_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::rebels_column_start + demographicswindow_main_table_header_t::rebels_column_width);
	if(col_um_rebels && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::rebels_column_start), float(y), float(demographicswindow_main_table_header_t::rebels_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
}
void demographicswindow_state_row_t::on_update(sys::state& state) noexcept {
// BEGIN state_row::update
// END
}
void demographicswindow_state_row_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::state_row"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	texture_key = win_data.texture;
	alt_texture_key = win_data.alt_texture;
	auto name_key = state.lookup_key("demographicswindow::state_row");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "folder_icon") {
			auto cptr = std::make_unique<demographicswindow_state_row_folder_icon_t>();
			cptr->parent = this;
			folder_icon = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location") {
			auto cptr = std::make_unique<demographicswindow_state_row_location_t>();
			cptr->parent = this;
			location = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size") {
			auto cptr = std::make_unique<demographicswindow_state_row_size_t>();
			cptr->parent = this;
			size = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size_trend") {
			auto cptr = std::make_unique<demographicswindow_state_row_size_trend_t>();
			cptr->parent = this;
			size_trend = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture") {
			auto cptr = std::make_unique<demographicswindow_state_row_culture_t>();
			cptr->parent = this;
			culture = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job") {
			auto cptr = std::make_unique<demographicswindow_state_row_job_t>();
			cptr->parent = this;
			job = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion") {
			auto cptr = std::make_unique<demographicswindow_state_row_religion_t>();
			cptr->parent = this;
			religion = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "ideology") {
			auto cptr = std::make_unique<demographicswindow_state_row_ideology_t>();
			cptr->parent = this;
			ideology = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "issues") {
			auto cptr = std::make_unique<demographicswindow_state_row_issues_t>();
			cptr->parent = this;
			issues = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "militancy") {
			auto cptr = std::make_unique<demographicswindow_state_row_militancy_t>();
			cptr->parent = this;
			militancy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "consciousness") {
			auto cptr = std::make_unique<demographicswindow_state_row_consciousness_t>();
			cptr->parent = this;
			consciousness = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "employment") {
			auto cptr = std::make_unique<demographicswindow_state_row_employment_t>();
			cptr->parent = this;
			employment = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "literacy") {
			auto cptr = std::make_unique<demographicswindow_state_row_literacy_t>();
			cptr->parent = this;
			literacy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "money") {
			auto cptr = std::make_unique<demographicswindow_state_row_money_t>();
			cptr->parent = this;
			money = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "needs") {
			auto cptr = std::make_unique<demographicswindow_state_row_needs_t>();
			cptr->parent = this;
			needs = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "frames") {
			auto cptr = std::make_unique<demographicswindow_state_row_frames_t>();
			cptr->parent = this;
			frames = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "focus_button") {
			auto cptr = std::make_unique<demographicswindow_state_row_focus_button_t>();
			cptr->parent = this;
			focus_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN state_row::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_state_row(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_state_row_t>();
	ptr->on_create(state);
	return ptr;
}
ui::message_result demographicswindow_province_row_folder_icon_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN province_row::folder_icon::lbutton_action
	if(popwindow::open_provs.contains(province_row.content.index()))
		popwindow::open_provs.erase(province_row.content.index());
	else
		popwindow::open_provs.insert(province_row.content.index());
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_province_row_folder_icon_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_province_row_folder_icon_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_province_row_folder_icon_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::folder_icon::update
	is_active = popwindow::open_provs.contains(province_row.content.index());
// END
}
void demographicswindow_province_row_folder_icon_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::folder_icon::create
// END
}
void demographicswindow_province_row_location_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_province_row_location_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_province_row_location_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_province_row_location_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::location::update
	set_text(state, text::produce_simple_string(state, state.world.province_get_name(province_row.content)));
// END
}
void demographicswindow_province_row_location_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::location::create
// END
}
void demographicswindow_province_row_size_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_province_row_size_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_province_row_size_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_province_row_size_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::size::update
	float total = 0.0f;
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				total += o.get_pop().get_size();
			}
		}
	
	set_text(state, text::prettify(int64_t(total)));
// END
}
void demographicswindow_province_row_size_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::size::create
// END
}
ui::message_result demographicswindow_province_row_size_trend_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_size_trend_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_size_trend_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::size_trend::tooltip
	auto box = text::open_layout_box(contents);
	text::localised_format_box(state, contents, box, "pop_growth_1");
	auto result = demographics::get_monthly_pop_increase(state, province_row.content);

	if(result >= 0) {
		text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
		text::add_to_layout_box(state, contents, box, int64_t(result), text::text_color::green);
	} else {
		text::add_to_layout_box(state, contents, box, int64_t(result), text::text_color::red);
	}
	text::close_layout_box(contents, box);
// END
}
void demographicswindow_province_row_size_trend_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_province_row_size_trend_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::size_trend::update
	auto result = demographics::get_monthly_pop_increase(state, province_row.content);
	if(result > 0) {
		frame = 0;
	} else if(result < 0) {
		frame = 2;
	} else {
		frame = 1;
	}
// END
}
void demographicswindow_province_row_size_trend_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN province_row::size_trend::create
// END
}
ui::message_result demographicswindow_province_row_culture_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_culture_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_culture_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_province_row_culture_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN province_row::culture::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.culture_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_province_row_culture_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_province_row_culture_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::culture::update
	auto cultures = state.world.culture_make_vectorizable_float_buffer();
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_culture();
				if(c)
					cultures.get(c) += o.get_pop().get_size();
			}
		}
	graph_content.clear();
	for(auto c : state.world.in_culture) {
		if(cultures.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), cultures.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_province_row_culture_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::culture::create
// END
}
ui::message_result demographicswindow_province_row_job_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_job_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_job_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_province_row_job_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN province_row::job::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.pop_type_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_province_row_job_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_province_row_job_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::job::update
	auto jobs = state.world.pop_type_make_vectorizable_float_buffer();
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_poptype();
				if(c)
					jobs.get(c) += o.get_pop().get_size();
			}
		}
	graph_content.clear();
	for(auto c : state.world.in_pop_type) {
		if(jobs.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), jobs.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_province_row_job_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::job::create
// END
}
ui::message_result demographicswindow_province_row_religion_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_religion_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_religion_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_province_row_religion_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN province_row::religion::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.religion_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_province_row_religion_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_province_row_religion_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::religion::update
	auto religions = state.world.religion_make_vectorizable_float_buffer();
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto c = o.get_pop().get_religion();
				if(c)
					religions.get(c) += o.get_pop().get_size();
			}
		}
	graph_content.clear();
	for(auto c : state.world.in_religion) {
		if(religions.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), religions.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_province_row_religion_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::religion::create
// END
}
ui::message_result demographicswindow_province_row_ideology_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_ideology_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_ideology_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_province_row_ideology_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN province_row::ideology::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.ideology_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_province_row_ideology_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_province_row_ideology_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::ideology::update
	auto ideologies = state.world.ideology_make_vectorizable_float_buffer();
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto sz = o.get_pop().get_size();
				for(auto i : state.world.in_ideology) {
					ideologies.get(i) = ideologies.get(i) + sz * pop_demographics::from_pu16(o.get_pop().get_udemographics(pop_demographics::to_key(state, i)));
				}
			}
		}
	
	graph_content.clear();
	for(auto c : state.world.in_ideology) {
		if(ideologies.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(c.get_color()), ideologies.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_province_row_ideology_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::ideology::create
// END
}
ui::message_result demographicswindow_province_row_issues_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_issues_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_issues_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_province_row_issues_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN province_row::issues::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.issue_get_name(state.world.issue_option_get_parent_issue(selected_key)));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, state.world.issue_option_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_province_row_issues_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_province_row_issues_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::issues::update
	auto issues = state.world.issue_option_make_vectorizable_float_buffer();
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				auto sz = o.get_pop().get_size();
				for(auto i : state.world.in_issue_option) {
					issues.get(i) = issues.get(i) + sz * pop_demographics::from_pu16(o.get_pop().get_udemographics(pop_demographics::to_key(state, i)));
				}
			}
		}
	graph_content.clear();
	for(auto c : state.world.in_issue_option) {
		if(issues.get(c) > 0.0f) {
			graph_content.emplace_back(graph_entry{ c.id, ogl::unpack_color(ogl::get_ui_color(state, c.id)), issues.get(c) });
		}
	}
	update_chart(state);
// END
}
void demographicswindow_province_row_issues_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::issues::create
// END
}
void demographicswindow_province_row_militancy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_province_row_militancy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_province_row_militancy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_province_row_militancy_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::militancy::update
	float total = 0.0f;
	float sz = 0.0f;
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::from_pmc(o.get_pop().get_umilitancy()) * o.get_pop().get_size();
			}
		}
	set_text(state, text::format_float(sz > 0 ? total / sz : 0.0f, 1));
// END
}
void demographicswindow_province_row_militancy_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::militancy::create
// END
}
void demographicswindow_province_row_consciousness_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_province_row_consciousness_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_province_row_consciousness_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_province_row_consciousness_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::consciousness::update
	float total = 0.0f;
	float sz = 0.0f;
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::from_pmc(o.get_pop().get_uconsciousness()) * o.get_pop().get_size();
			}
		}
	set_text(state, text::format_float(sz > 0 ? total / sz : 0.0f, 1));
// END
}
void demographicswindow_province_row_consciousness_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::consciousness::create
// END
}
void demographicswindow_province_row_employment_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_province_row_employment_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_province_row_employment_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_province_row_employment_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::employment::update
	float total = 0.0f;
	float sz = 0.0f;
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				if(o.get_pop().get_poptype().get_has_unemployment()) {
					sz += o.get_pop().get_size();
					total += pop_demographics::get_employment(state, o.get_pop());
				} else {
					sz += o.get_pop().get_size();
					total += o.get_pop().get_size();
				}
			}
		}
	set_text(state, text::format_percentage(sz > 0 ? total / sz : 0.0f, 0));
// END
}
void demographicswindow_province_row_employment_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::employment::create
// END
}
void demographicswindow_province_row_literacy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_province_row_literacy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_province_row_literacy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_province_row_literacy_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::literacy::update
	float total = 0.0f;
	float sz = 0.0f;
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				total += pop_demographics::get_literacy(state, o.get_pop()) * o.get_pop().get_size();
			}
		}
	set_text(state, text::format_percentage(sz > 0 ? total / sz : 0.0f, 0));
// END
}
void demographicswindow_province_row_literacy_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::literacy::create
// END
}
void demographicswindow_province_row_money_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_province_row_money_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_province_row_money_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_province_row_money_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::money::update
	float total = 0.0f;
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				total += o.get_pop().get_savings();
			}
		}
	set_text(state, text::prettify_currency(total));
// END
}
void demographicswindow_province_row_money_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::money::create
// END
}
ui::message_result demographicswindow_province_row_needs_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_needs_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_needs_t::update_chart(sys::state& state) {
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 99; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 99; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(99)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_province_row_needs_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN province_row::needs::tooltip
		float total = 0.0f;
		auto box = text::open_layout_box(contents);
		if(temp_index == 0 || temp_index == 1) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("life_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[0].amount });
		} else if(temp_index == 2 || temp_index == 3) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("everyday_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[2].amount });
		} else if(temp_index == 4 || temp_index == 5) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("luxury_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[4].amount });
		}

		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_province_row_needs_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_province_row_needs_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::needs::update
	float lntotal = 0.0f;
	float entotal = 0.0f;
	float lxtotal = 0.0f;
	float sz = 0.0f;
	
		for(auto o : state.world.province_get_pop_location(province_row.content)) {
			if(alice_ui::pop_passes_filter(state, o.get_pop())) {
				sz += o.get_pop().get_size();
				lntotal += pop_demographics::get_life_needs(state, o.get_pop()) * o.get_pop().get_size();
				entotal += pop_demographics::get_everyday_needs(state, o.get_pop()) * o.get_pop().get_size();
				lxtotal += pop_demographics::get_luxury_needs(state, o.get_pop()) * o.get_pop().get_size();
			}
		}

	graph_content.clear();
	graph_content.emplace_back(graph_entry{ 0, ogl::color3f{ 130.0f / 255.0f, 162.0f / 255.0f, 217.0f / 255.0f }, sz > 0.0f ? lntotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 1, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - lntotal / sz : 1.0f });
	graph_content.emplace_back(graph_entry{ 2, ogl::color3f{ 210.0f / 255.0f, 140.0f / 255.0f, 37.0f / 255.0f }, sz > 0.0f ? entotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 3, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - entotal / sz : 1.0f });
	graph_content.emplace_back(graph_entry{ 4, ogl::color3f{ 157.0f / 255.0f, 66.0f / 255.0f, 62.0f / 255.0f }, sz > 0.0f ? lxtotal / sz : 0.0f });
	graph_content.emplace_back(graph_entry{ 5, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, sz > 0.0f ? 1.0f - lxtotal / sz : 1.0f });
	update_chart(state);
// END
}
void demographicswindow_province_row_needs_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::needs::create
// END
}
ui::message_result demographicswindow_province_row_frames_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_province_row_frames_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_province_row_frames_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_province_row_frames_t::on_update(sys::state& state) noexcept {
	demographicswindow_province_row_t& province_row = *((demographicswindow_province_row_t*)(parent)); 
// BEGIN province_row::frames::update
// END
}
void demographicswindow_province_row_frames_t::on_create(sys::state& state) noexcept {
// BEGIN province_row::frames::create
// END
}
ui::message_result demographicswindow_province_row_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_province_row_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_province_row_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	auto under_mouse = [&](){auto p = state.ui_state.under_mouse; while(p){ if(p == this) return true; p = p->parent; } return false;}();
	int32_t rel_mouse_x = int32_t(state.mouse_x_position / state.user_settings.ui_scale) - ui::get_absolute_location(state, *this).x;
	if(under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x), float(y), float(base_data.size.x), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_spacer = rel_mouse_x >= demographicswindow_main_table_header_t::spacer_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::spacer_column_start + demographicswindow_main_table_header_t::spacer_column_width);
	bool col_um_location = rel_mouse_x >= demographicswindow_main_table_header_t::location_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::location_column_start + demographicswindow_main_table_header_t::location_column_width);
	if(col_um_location && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::location_column_start), float(y), float(demographicswindow_main_table_header_t::location_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_size = rel_mouse_x >= demographicswindow_main_table_header_t::size_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::size_column_start + demographicswindow_main_table_header_t::size_column_width);
	if(col_um_size && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::size_column_start), float(y), float(demographicswindow_main_table_header_t::size_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_culture = rel_mouse_x >= demographicswindow_main_table_header_t::culture_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::culture_column_start + demographicswindow_main_table_header_t::culture_column_width);
	if(col_um_culture && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::culture_column_start), float(y), float(demographicswindow_main_table_header_t::culture_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_job = rel_mouse_x >= demographicswindow_main_table_header_t::job_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::job_column_start + demographicswindow_main_table_header_t::job_column_width);
	if(col_um_job && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::job_column_start), float(y), float(demographicswindow_main_table_header_t::job_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_religion = rel_mouse_x >= demographicswindow_main_table_header_t::religion_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::religion_column_start + demographicswindow_main_table_header_t::religion_column_width);
	if(col_um_religion && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::religion_column_start), float(y), float(demographicswindow_main_table_header_t::religion_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_ideology = rel_mouse_x >= demographicswindow_main_table_header_t::ideology_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::ideology_column_start + demographicswindow_main_table_header_t::ideology_column_width);
	if(col_um_ideology && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::ideology_column_start), float(y), float(demographicswindow_main_table_header_t::ideology_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_issues = rel_mouse_x >= demographicswindow_main_table_header_t::issues_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::issues_column_start + demographicswindow_main_table_header_t::issues_column_width);
	if(col_um_issues && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::issues_column_start), float(y), float(demographicswindow_main_table_header_t::issues_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_militancy = rel_mouse_x >= demographicswindow_main_table_header_t::militancy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::militancy_column_start + demographicswindow_main_table_header_t::militancy_column_width);
	if(col_um_militancy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::militancy_column_start), float(y), float(demographicswindow_main_table_header_t::militancy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_consciousness = rel_mouse_x >= demographicswindow_main_table_header_t::consciousness_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::consciousness_column_start + demographicswindow_main_table_header_t::consciousness_column_width);
	if(col_um_consciousness && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::consciousness_column_start), float(y), float(demographicswindow_main_table_header_t::consciousness_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_employment = rel_mouse_x >= demographicswindow_main_table_header_t::employment_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::employment_column_start + demographicswindow_main_table_header_t::employment_column_width);
	if(col_um_employment && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::employment_column_start), float(y), float(demographicswindow_main_table_header_t::employment_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_literacy = rel_mouse_x >= demographicswindow_main_table_header_t::literacy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::literacy_column_start + demographicswindow_main_table_header_t::literacy_column_width);
	if(col_um_literacy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::literacy_column_start), float(y), float(demographicswindow_main_table_header_t::literacy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_money = rel_mouse_x >= demographicswindow_main_table_header_t::money_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::money_column_start + demographicswindow_main_table_header_t::money_column_width);
	if(col_um_money && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::money_column_start), float(y), float(demographicswindow_main_table_header_t::money_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_needs = rel_mouse_x >= demographicswindow_main_table_header_t::needs_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::needs_column_start + demographicswindow_main_table_header_t::needs_column_width);
	if(col_um_needs && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::needs_column_start), float(y), float(demographicswindow_main_table_header_t::needs_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_rebels = rel_mouse_x >= demographicswindow_main_table_header_t::rebels_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::rebels_column_start + demographicswindow_main_table_header_t::rebels_column_width);
	if(col_um_rebels && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::rebels_column_start), float(y), float(demographicswindow_main_table_header_t::rebels_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
}
void demographicswindow_province_row_t::on_update(sys::state& state) noexcept {
// BEGIN province_row::update
// END
}
void demographicswindow_province_row_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::province_row"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	texture_key = win_data.texture;
	alt_texture_key = win_data.alt_texture;
	auto name_key = state.lookup_key("demographicswindow::province_row");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "folder_icon") {
			auto cptr = std::make_unique<demographicswindow_province_row_folder_icon_t>();
			cptr->parent = this;
			folder_icon = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location") {
			auto cptr = std::make_unique<demographicswindow_province_row_location_t>();
			cptr->parent = this;
			location = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size") {
			auto cptr = std::make_unique<demographicswindow_province_row_size_t>();
			cptr->parent = this;
			size = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size_trend") {
			auto cptr = std::make_unique<demographicswindow_province_row_size_trend_t>();
			cptr->parent = this;
			size_trend = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture") {
			auto cptr = std::make_unique<demographicswindow_province_row_culture_t>();
			cptr->parent = this;
			culture = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job") {
			auto cptr = std::make_unique<demographicswindow_province_row_job_t>();
			cptr->parent = this;
			job = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion") {
			auto cptr = std::make_unique<demographicswindow_province_row_religion_t>();
			cptr->parent = this;
			religion = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "ideology") {
			auto cptr = std::make_unique<demographicswindow_province_row_ideology_t>();
			cptr->parent = this;
			ideology = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "issues") {
			auto cptr = std::make_unique<demographicswindow_province_row_issues_t>();
			cptr->parent = this;
			issues = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "militancy") {
			auto cptr = std::make_unique<demographicswindow_province_row_militancy_t>();
			cptr->parent = this;
			militancy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "consciousness") {
			auto cptr = std::make_unique<demographicswindow_province_row_consciousness_t>();
			cptr->parent = this;
			consciousness = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "employment") {
			auto cptr = std::make_unique<demographicswindow_province_row_employment_t>();
			cptr->parent = this;
			employment = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "literacy") {
			auto cptr = std::make_unique<demographicswindow_province_row_literacy_t>();
			cptr->parent = this;
			literacy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "money") {
			auto cptr = std::make_unique<demographicswindow_province_row_money_t>();
			cptr->parent = this;
			money = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "needs") {
			auto cptr = std::make_unique<demographicswindow_province_row_needs_t>();
			cptr->parent = this;
			needs = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "frames") {
			auto cptr = std::make_unique<demographicswindow_province_row_frames_t>();
			cptr->parent = this;
			frames = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN province_row::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_province_row(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_province_row_t>();
	ptr->on_create(state);
	return ptr;
}
void demographicswindow_pop_row_location_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_location_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_location_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_location_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::location::update
	if(popwindow::show_only_pops) {
		auto loc = state.world.pop_get_province_from_pop_location(pop_row.value);
		auto txt = text::produce_simple_string(state, state.world.province_get_name(loc)) + " (" + text::get_short_state_name(state, state.world.province_get_state_membership(loc)) + ")";
		set_text(state, txt);
	} else {
		set_text(state, "");
	}
// END
}
void demographicswindow_pop_row_location_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::location::create
// END
}
void demographicswindow_pop_row_size_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::size::tooltip
	auto pop = pop_row.value;
	auto growth = int64_t(demographics::get_monthly_pop_increase(state, pop));
	auto promote = -int64_t(demographics::get_estimated_type_change(state, pop));
	auto assimilation = -int64_t(demographics::get_estimated_assimilation(state, pop));
	auto internal_migration = -int64_t(demographics::get_estimated_internal_migration(state, pop));
	auto colonial_migration = -int64_t(demographics::get_estimated_colonial_migration(state, pop));
	auto emigration = -int64_t(demographics::get_estimated_emigration(state, pop));
	auto total = int64_t(growth) + promote + assimilation + internal_migration + colonial_migration + emigration;

	{
		auto box = text::open_layout_box(contents);
		text::localised_format_box(state, contents, box, "pop_size_1");
		if(total >= 0) {
			text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
			text::add_to_layout_box(state, contents, box, total, text::text_color::green);
		} else {
			text::add_to_layout_box(state, contents, box, total, text::text_color::red);
		}
		text::close_layout_box(contents, box);
	}
	text::add_line_break_to_layout(state, contents);
	{
		auto box = text::open_layout_box(contents);
		text::localised_format_box(state, contents, box, "pop_size_2");
		if(growth >= 0) {
			text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
			text::add_to_layout_box(state, contents, box, growth, text::text_color::green);
		} else {
			text::add_to_layout_box(state, contents, box, growth, text::text_color::red);
		}
		text::close_layout_box(contents, box);
	}
	{
		auto box = text::open_layout_box(contents);
		text::localised_format_box(state, contents, box, "pop_size_3");
		if(promote >= 0) {
			text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
			text::add_to_layout_box(state, contents, box, promote, text::text_color::green);
		} else {
			text::add_to_layout_box(state, contents, box, promote, text::text_color::red);
		}
		text::close_layout_box(contents, box);
	}
	{
		auto box = text::open_layout_box(contents);
		text::localised_format_box(state, contents, box, "pop_size_4");
		if(assimilation >= 0) {
			text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
			text::add_to_layout_box(state, contents, box, assimilation, text::text_color::green);
		} else {
			text::add_to_layout_box(state, contents, box, assimilation, text::text_color::red);
		}
		text::close_layout_box(contents, box);
	}
	{
		auto box = text::open_layout_box(contents);
		text::localised_format_box(state, contents, box, "pop_size_5");
		if(internal_migration >= 0) {
			text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
			text::add_to_layout_box(state, contents, box, internal_migration, text::text_color::green);
		} else {
			text::add_to_layout_box(state, contents, box, internal_migration, text::text_color::red);
		}
		text::close_layout_box(contents, box);
	}
	{
		auto box = text::open_layout_box(contents);
		text::localised_format_box(state, contents, box, "pop_size_6");
		if(colonial_migration >= 0) {
			text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
			text::add_to_layout_box(state, contents, box, colonial_migration, text::text_color::green);
		} else {
			text::add_to_layout_box(state, contents, box, colonial_migration, text::text_color::red);
		}
		text::close_layout_box(contents, box);
	}
	{
		auto box = text::open_layout_box(contents);
		text::localised_format_box(state, contents, box, "pop_size_7");
		if(emigration >= 0) {
			text::add_to_layout_box(state, contents, box, std::string_view{ "+" }, text::text_color::green);
			text::add_to_layout_box(state, contents, box, emigration, text::text_color::green);
		} else {
			text::add_to_layout_box(state, contents, box, emigration, text::text_color::red);
		}
		text::close_layout_box(contents, box);
	}
// END
}
void demographicswindow_pop_row_size_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_size_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_size_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_size_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::size::update
	set_text(state, text::prettify(int64_t(state.world.pop_get_size(pop_row.value))));
// END
}
void demographicswindow_pop_row_size_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::size::create
// END
}
ui::message_result demographicswindow_pop_row_size_trend_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_size_trend_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_size_trend_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::size_trend::tooltip
	ui::describe_growth(state, contents, pop_row.value);
// END
}
void demographicswindow_pop_row_size_trend_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_pop_row_size_trend_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::size_trend::update
	auto result = int64_t(demographics::get_monthly_pop_increase(state, pop_row.value));
	if(result > 0) {
		frame = 0;
	} else if(result < 0) {
		frame = 2;
	} else {
		frame = 1;
	}
// END
}
void demographicswindow_pop_row_size_trend_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN pop_row::size_trend::create
// END
}
ui::message_result demographicswindow_pop_row_culture_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_culture_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_culture_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::culture::tooltip
	text::add_line(state, contents, state.world.pop_get_culture(pop_row.value).get_name());
// END
}
void demographicswindow_pop_row_culture_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
		ogl::render_alpha_colored_rect(state, float(x ), float(y), float(base_data.size.x), float(base_data.size.y), color.r, color.g, color.b, color.a);
}
void demographicswindow_pop_row_culture_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::culture::update
	auto c = ogl::unpack_color(state.world.pop_get_culture(pop_row.value).get_color());
	color.r = c.r; color.b = c.b; color.g = c.g;
// END
}
void demographicswindow_pop_row_culture_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::culture::create
// END
}
ui::message_result demographicswindow_pop_row_job_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_job_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_job_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::job::tooltip
	text::add_line(state, contents, state.world.pop_get_poptype(pop_row.value).get_name());
// END
}
void demographicswindow_pop_row_job_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_pop_row_job_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::job::update
	frame = int32_t(state.world.pop_get_poptype(pop_row.value).get_sprite()) - 1;
// END
}
void demographicswindow_pop_row_job_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN pop_row::job::create
// END
}
ui::message_result demographicswindow_pop_row_religion_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_religion_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_religion_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::religion::tooltip
	text::add_line(state, contents, state.world.pop_get_religion(pop_row.value).get_name());
// END
}
void demographicswindow_pop_row_religion_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_pop_row_religion_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::religion::update
	frame = int32_t(state.world.pop_get_religion(pop_row.value).get_icon()) - 1;
// END
}
void demographicswindow_pop_row_religion_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN pop_row::religion::create
// END
}
ui::message_result demographicswindow_pop_row_ideology_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_ideology_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_ideology_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_pop_row_ideology_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN pop_row::ideology::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.ideology_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_pop_row_ideology_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_pop_row_ideology_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::ideology::update
	graph_content.clear();
	for(auto i : state.world.in_ideology) {
		auto amount = pop_demographics::get_demo(state, pop_row.value, pop_demographics::to_key(state, i));
		if(amount > 0)
			graph_content.emplace_back(graph_entry{ i, ogl::unpack_color(i.get_color()),  amount });
	}
	update_chart(state);
// END
}
void demographicswindow_pop_row_ideology_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::ideology::create
// END
}
ui::message_result demographicswindow_pop_row_issues_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_issues_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_issues_t::update_chart(sys::state& state) {
	std::sort(graph_content.begin(), graph_content.end(), [](auto const& a, auto const& b) { return a.amount > b.amount; });
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 100; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 100; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(100)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_pop_row_issues_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN pop_row::issues::tooltip
		float total = 0.0f;
		for(auto& i : graph_content)
			total += i.amount;
		auto box = text::open_layout_box(contents);
		text::add_to_layout_box(state, contents, box, state.world.issue_get_name(state.world.issue_option_get_parent_issue(selected_key)));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, state.world.issue_option_get_name(selected_key));
		text::add_space_to_layout_box(state, contents, box);
		text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ total > 0.0f ? graph_content[temp_index].amount / total : 0.0f });
		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_pop_row_issues_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_pop_row_issues_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::issues::update
	graph_content.clear();
	for(auto i : state.world.in_issue_option) {
		auto amount = pop_demographics::get_demo(state, pop_row.value, pop_demographics::to_key(state, i));
		if(amount > 0)
			graph_content.emplace_back(graph_entry{ i, ogl::unpack_color(ogl::get_ui_color(state,i.id)),  amount });
	}
	update_chart(state);
// END
}
void demographicswindow_pop_row_issues_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::issues::create
// END
}
void demographicswindow_pop_row_militancy_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::militancy::tooltip
	ui::describe_mil(state, contents, pop_row.value);
// END
}
void demographicswindow_pop_row_militancy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_militancy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_militancy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_militancy_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::militancy::update
	set_text(state, text::format_float(pop_demographics::get_militancy(state, pop_row.value), 1));
// END
}
void demographicswindow_pop_row_militancy_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::militancy::create
// END
}
void demographicswindow_pop_row_consciousness_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::consciousness::tooltip
	ui::describe_con(state, contents, pop_row.value);
// END
}
void demographicswindow_pop_row_consciousness_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_consciousness_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_consciousness_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_consciousness_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::consciousness::update
	set_text(state, text::format_float(pop_demographics::get_consciousness(state, pop_row.value), 1));
// END
}
void demographicswindow_pop_row_consciousness_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::consciousness::create
// END
}
void demographicswindow_pop_row_employment_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_employment_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_employment_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_employment_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::employment::update
	if(state.world.pop_get_poptype(pop_row.value).get_has_unemployment()) {
		auto sz = state.world.pop_get_size(pop_row.value);
		set_text(state, text::format_percentage(sz > 0 ? pop_demographics::get_employment(state, pop_row.value) / sz : 0.0f, 0));
	} else {
		set_text(state, "-");
	}
// END
}
void demographicswindow_pop_row_employment_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::employment::create
// END
}
void demographicswindow_pop_row_literacy_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::literacy::tooltip
	ui::describe_lit(state, contents, pop_row.value);
// END
}
void demographicswindow_pop_row_literacy_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_literacy_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_literacy_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_literacy_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::literacy::update
	set_text(state, text::format_percentage(pop_demographics::get_literacy(state, pop_row.value), 0));
// END
}
void demographicswindow_pop_row_literacy_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::literacy::create
// END
}
void demographicswindow_pop_row_money_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_money_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_money_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_money_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::money::update
	set_text(state, text::prettify_currency(state.world.pop_get_savings(pop_row.value)));
// END
}
void demographicswindow_pop_row_money_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::money::create
// END
}
ui::message_result demographicswindow_pop_row_needs_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_needs_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_needs_t::update_chart(sys::state& state) {
	float total = 0.0f;
	for(auto& e : graph_content) { total += e.amount; }
	if(total <= 0.0f) {
		for(int32_t k = 0; k < 99; k++) {
			data_texture.data[k * 3] = uint8_t(0);
			data_texture.data[k * 3 + 1] = uint8_t(0);
			data_texture.data[k * 3 + 2] = uint8_t(0);
		}
		data_texture.data_updated = true;
		return;
	}
	int32_t index = 0;
	float offset = 0.0f;
	for(int32_t k = 0; k < 99; k++) {
		if(graph_content[index].amount + offset < (float(k) + 0.5f) * total /  float(99)) {
			offset += graph_content[index].amount;
			++index;
		}
		data_texture.data[k * 3] = uint8_t(graph_content[index].color.r * 255.0f);
		data_texture.data[k * 3 + 1] = uint8_t(graph_content[index].color.g * 255.0f);
		data_texture.data[k * 3 + 2] = uint8_t(graph_content[index].color.b * 255.0f);
	}
	data_texture.data_updated = true;
}
void demographicswindow_pop_row_needs_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
	float temp_total = 0.0f;
	for(auto& p : graph_content) { temp_total += p.amount; }
	float temp_offset = temp_total * float(x) / float(base_data.size.x);
	int32_t temp_index = 0;
	for(auto& p : graph_content) { if(temp_offset <= p.amount) break; temp_offset -= p.amount; ++temp_index; }
	if(temp_index < int32_t(graph_content.size())) {
		auto& selected_key = graph_content[temp_index].key;
// BEGIN pop_row::needs::tooltip
		float total = 0.0f;
		auto box = text::open_layout_box(contents);
		if(temp_index == 0 || temp_index == 1) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("life_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[0].amount });
		} else if(temp_index == 2 || temp_index == 3) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("everyday_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[2].amount });
		} else if(temp_index == 4 || temp_index == 5) {
			text::add_to_layout_box(state, contents, box, state.lookup_key("luxury_needs"));
			text::add_space_to_layout_box(state, contents, box);
			text::add_to_layout_box(state, contents, box, text::fp_percentage_one_place{ graph_content[4].amount });
		}

		text::close_layout_box(contents, box);
// END
	}
}
void demographicswindow_pop_row_needs_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_stripchart(state, ogl::color_modification::none, float(x), float(y), float(base_data.size.x), float(base_data.size.y), data_texture);
}
void demographicswindow_pop_row_needs_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::needs::update
	float lntotal = pop_demographics::get_life_needs(state, pop_row.value);
	float entotal = pop_demographics::get_everyday_needs(state, pop_row.value);
	float lxtotal = pop_demographics::get_luxury_needs(state, pop_row.value);

	graph_content.clear();
	graph_content.emplace_back(graph_entry{ 0, ogl::color3f{ 130.0f / 255.0f, 162.0f / 255.0f, 217.0f / 255.0f }, lntotal  });
	graph_content.emplace_back(graph_entry{ 1, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f },  1.0f - lntotal });
	graph_content.emplace_back(graph_entry{ 2, ogl::color3f{ 210.0f / 255.0f, 140.0f / 255.0f, 37.0f / 255.0f }, entotal });
	graph_content.emplace_back(graph_entry{ 3, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f },  1.0f - entotal });
	graph_content.emplace_back(graph_entry{ 4, ogl::color3f{ 157.0f / 255.0f, 66.0f / 255.0f, 62.0f / 255.0f },  lxtotal });
	graph_content.emplace_back(graph_entry{ 5, ogl::color3f{ 206.0f / 255.0f, 199.0f / 255.0f, 181.0f / 255.0f }, 1.0f - lxtotal });
	update_chart(state);
// END
}
void demographicswindow_pop_row_needs_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::needs::create
// END
}
ui::message_result demographicswindow_pop_row_rebel_flag_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	if(std::holds_alternative<dcon::nation_id>(flag)) {
		if(std::get<dcon::nation_id>(flag) && state.world.nation_get_owned_province_count(std::get<dcon::nation_id>(flag)) > 0) {
			sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
			state.open_diplomacy(std::get<dcon::nation_id>(flag));
		} 
	} else if(std::holds_alternative<dcon::national_identity_id>(flag)) {
		auto n_temp = state.world.national_identity_get_nation_from_identity_holder(std::get<dcon::national_identity_id>(flag));
		if(n_temp && state.world.nation_get_owned_province_count(n_temp) > 0) {
			sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
			state.open_diplomacy(n_temp);
		} 
	} 
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_pop_row_rebel_flag_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_rebel_flag_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	if(std::holds_alternative<dcon::nation_id>(flag)) {
		text::add_line(state, contents, text::get_name(state, std::get<dcon::nation_id>(flag)));
	} else if(std::holds_alternative<dcon::national_identity_id>(flag)) {
		text::add_line(state, contents, nations::name_from_tag(state, std::get<dcon::national_identity_id>(flag)));
	} else if(std::holds_alternative<dcon::rebel_faction_id>(flag)) {
		auto box = text::open_layout_box(contents, 0);
		text::add_to_layout_box(state, contents, box, rebel::rebel_name(state, std::get<dcon::rebel_faction_id>(flag)));
		text::close_layout_box(contents, box);
	} 
}
void demographicswindow_pop_row_rebel_flag_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(std::holds_alternative<dcon::nation_id>(flag)) {
		culture::flag_type flag_type = culture::flag_type{};
		auto h_temp = state.world.nation_get_identity_from_identity_holder(std::get<dcon::nation_id>(flag));
		if(bool(std::get<dcon::nation_id>(flag)) && state.world.nation_get_owned_province_count(std::get<dcon::nation_id>(flag)) != 0) {
			flag_type = culture::get_current_flag_type(state, std::get<dcon::nation_id>(flag));
		} else {
			flag_type = culture::get_current_flag_type(state, h_temp);
		}
		auto flag_texture_handle = ogl::get_flag_handle(state, h_temp, flag_type);
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), flag_texture_handle, base_data.get_rotation(), false,  false);
	} else if(std::holds_alternative<dcon::national_identity_id>(flag)) {
		culture::flag_type flag_type = culture::flag_type{};
		auto n_temp = state.world.national_identity_get_nation_from_identity_holder(std::get<dcon::national_identity_id>(flag));
		if(bool(n_temp) && state.world.nation_get_owned_province_count(n_temp) != 0) {
			flag_type = culture::get_current_flag_type(state, n_temp);
		} else {
			flag_type = culture::get_current_flag_type(state, std::get<dcon::national_identity_id>(flag));
		}
		auto flag_texture_handle = ogl::get_flag_handle(state, std::get<dcon::national_identity_id>(flag), flag_type);
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), flag_texture_handle, base_data.get_rotation(), false,  false);
	} else if(std::holds_alternative<dcon::rebel_faction_id>(flag)) {
		dcon::rebel_faction_id rf_temp = std::get<dcon::rebel_faction_id>(flag);
		if(state.world.rebel_faction_get_type(rf_temp).get_independence() != uint8_t(culture::rebel_independence::none) && state.world.rebel_faction_get_defection_target(rf_temp)) {
			culture::flag_type flag_type = culture::flag_type{};
			auto h_temp = state.world.rebel_faction_get_defection_target(rf_temp);
			auto n_temp = state.world.national_identity_get_nation_from_identity_holder(h_temp);
			if(bool(n_temp) && state.world.nation_get_owned_province_count(n_temp) != 0) {
				flag_type = culture::get_current_flag_type(state, n_temp);
			} else {
				flag_type = culture::get_current_flag_type(state, h_temp);
			}
			auto flag_texture_handle = ogl::get_flag_handle(state, h_temp, flag_type);
			ogl::render_textured_rect(state, ui::get_color_modification(false, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), flag_texture_handle, base_data.get_rotation(), false,  false);
			ogl::render_textured_rect(state, ui::get_color_modification(false, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_rebel_flag_overlay(state), base_data.get_rotation(), false,  false);
		return;
		}
		ogl::render_textured_rect(state, ui::get_color_modification(false, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_rebel_flag_handle(state, rf_temp), base_data.get_rotation(), false,  false);
	} 
}
void demographicswindow_pop_row_rebel_flag_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::rebel_flag::update
	if(auto rf = state.world.pop_get_rebel_faction_from_pop_rebellion_membership(pop_row.value); rf) {
		flag = rf;
		set_visible(state, true);
		return;
	}
	if(auto m = state.world.pop_get_movement_from_pop_movement_membership(pop_row.value); m) {
		if(auto id = state.world.movement_get_associated_independence(m); id) {
			flag = id;
			set_visible(state, true);
			return;
		}
	}
	set_visible(state, false);
// END
}
void demographicswindow_pop_row_rebel_flag_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::rebel_flag::create
// END
}
void demographicswindow_pop_row_culture_name_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::culture_name::tooltip
	ui::describe_assimilation(state, contents, pop_row.value);
// END
}
void demographicswindow_pop_row_culture_name_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_culture_name_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_culture_name_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_culture_name_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::culture_name::update
	set_text(state, text::produce_simple_string(state, state.world.pop_get_culture(pop_row.value).get_name()));
// END
}
void demographicswindow_pop_row_culture_name_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::culture_name::create
// END
}
void demographicswindow_pop_row_job_name_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_job_name_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_job_name_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_job_name_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::job_name::update
	set_text(state, text::produce_simple_string(state, state.world.pop_get_poptype(pop_row.value).get_name()));
// END
}
void demographicswindow_pop_row_job_name_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::job_name::create
// END
}
void demographicswindow_pop_row_religion_name_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_pop_row_religion_name_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_pop_row_religion_name_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_pop_row_religion_name_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::religion_name::update
	set_text(state, text::produce_simple_string(state, state.world.pop_get_religion(pop_row.value).get_name()));
// END
}
void demographicswindow_pop_row_religion_name_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::religion_name::create
// END
}
ui::message_result demographicswindow_pop_row_frames_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_frames_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_frames_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_pop_row_frames_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::frames::update
// END
}
void demographicswindow_pop_row_frames_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::frames::create
// END
}
ui::message_result demographicswindow_pop_row_movement_political_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_movement_political_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_movement_political_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::movement_political::tooltip
	auto m = state.world.pop_get_movement_from_pop_movement_membership(pop_row.value);
	if(m) {
		auto movement_issue = state.world.movement_get_associated_issue_option(m);
		text::add_line(state, contents, movement_issue.get_movement_name());
	}
// END
}
void demographicswindow_pop_row_movement_political_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_pop_row_movement_political_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::movement_political::update
	if(auto m = state.world.pop_get_movement_from_pop_movement_membership(pop_row.value); m) {
		auto parent_issue = state.world.movement_get_associated_issue_option(m).get_parent_issue();
		if(parent_issue.get_issue_type() == uint8_t(culture::issue_category::political)) {
			int32_t count = 0;
			for(; count < int32_t(state.culture_definitions.political_issues.size()); ++count) {
				if(state.culture_definitions.political_issues[count] == parent_issue)
					break;
			}
			set_visible(state, true);
			frame = count;
		}
	}
	set_visible(state, false);
// END
}
void demographicswindow_pop_row_movement_political_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN pop_row::movement_political::create
// END
}
ui::message_result demographicswindow_pop_row_movement_social_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_pop_row_movement_social_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_pop_row_movement_social_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::movement_social::tooltip
	auto m = state.world.pop_get_movement_from_pop_movement_membership(pop_row.value);
	if(m) {
		auto movement_issue = state.world.movement_get_associated_issue_option(m);
		text::add_line(state, contents, movement_issue.get_movement_name());
	}
// END
}
void demographicswindow_pop_row_movement_social_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_pop_row_movement_social_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::movement_social::update
	if(auto m = state.world.pop_get_movement_from_pop_movement_membership(pop_row.value); m) {
		auto parent_issue = state.world.movement_get_associated_issue_option(m).get_parent_issue();
		if(parent_issue.get_issue_type() == uint8_t(culture::issue_category::social)) {
			int32_t count = 0;
			for(; count < int32_t(state.culture_definitions.social_issues.size()); ++count) {
				if(state.culture_definitions.social_issues[count] == parent_issue)
					break;
			}
			set_visible(state, true);
			frame = count;
		}
	}
	set_visible(state, false);
// END
}
void demographicswindow_pop_row_movement_social_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN pop_row::movement_social::create
// END
}
ui::message_result demographicswindow_pop_row_details_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN pop_row::details_button::lbutton_action
	auto dwindow_ptr = (ui::pop_details_window**)(parent->parent->parent->get_by_name(state, "details_w"));
	assert(dwindow_ptr);
	Cyto::Any payload = ui::pop_details_data{ pop_row.value };
	(*dwindow_ptr)->impl_set(state, payload);
	if(!(*dwindow_ptr)->is_visible())
		(*dwindow_ptr)->set_visible(state, true);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_pop_row_details_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_pop_row_details_button_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	text::add_line(state, contents, tooltip_key);
}
void demographicswindow_pop_row_details_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_pop_row_details_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_pop_row_t& pop_row = *((demographicswindow_pop_row_t*)(parent)); 
// BEGIN pop_row::details_button::update
// END
}
void demographicswindow_pop_row_details_button_t::on_create(sys::state& state) noexcept {
// BEGIN pop_row::details_button::create
// END
}
ui::message_result demographicswindow_pop_row_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_pop_row_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_pop_row_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	auto under_mouse = [&](){auto p = state.ui_state.under_mouse; while(p){ if(p == this) return true; p = p->parent; } return false;}();
	int32_t rel_mouse_x = int32_t(state.mouse_x_position / state.user_settings.ui_scale) - ui::get_absolute_location(state, *this).x;
	if(under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x), float(y), float(base_data.size.x), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_spacer = rel_mouse_x >= demographicswindow_main_table_header_t::spacer_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::spacer_column_start + demographicswindow_main_table_header_t::spacer_column_width);
	bool col_um_location = rel_mouse_x >= demographicswindow_main_table_header_t::location_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::location_column_start + demographicswindow_main_table_header_t::location_column_width);
	if(col_um_location && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::location_column_start), float(y), float(demographicswindow_main_table_header_t::location_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_size = rel_mouse_x >= demographicswindow_main_table_header_t::size_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::size_column_start + demographicswindow_main_table_header_t::size_column_width);
	if(col_um_size && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::size_column_start), float(y), float(demographicswindow_main_table_header_t::size_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_culture = rel_mouse_x >= demographicswindow_main_table_header_t::culture_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::culture_column_start + demographicswindow_main_table_header_t::culture_column_width);
	if(col_um_culture && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::culture_column_start), float(y), float(demographicswindow_main_table_header_t::culture_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_job = rel_mouse_x >= demographicswindow_main_table_header_t::job_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::job_column_start + demographicswindow_main_table_header_t::job_column_width);
	if(col_um_job && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::job_column_start), float(y), float(demographicswindow_main_table_header_t::job_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_religion = rel_mouse_x >= demographicswindow_main_table_header_t::religion_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::religion_column_start + demographicswindow_main_table_header_t::religion_column_width);
	if(col_um_religion && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::religion_column_start), float(y), float(demographicswindow_main_table_header_t::religion_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_ideology = rel_mouse_x >= demographicswindow_main_table_header_t::ideology_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::ideology_column_start + demographicswindow_main_table_header_t::ideology_column_width);
	if(col_um_ideology && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::ideology_column_start), float(y), float(demographicswindow_main_table_header_t::ideology_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_issues = rel_mouse_x >= demographicswindow_main_table_header_t::issues_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::issues_column_start + demographicswindow_main_table_header_t::issues_column_width);
	if(col_um_issues && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::issues_column_start), float(y), float(demographicswindow_main_table_header_t::issues_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_militancy = rel_mouse_x >= demographicswindow_main_table_header_t::militancy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::militancy_column_start + demographicswindow_main_table_header_t::militancy_column_width);
	if(col_um_militancy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::militancy_column_start), float(y), float(demographicswindow_main_table_header_t::militancy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_consciousness = rel_mouse_x >= demographicswindow_main_table_header_t::consciousness_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::consciousness_column_start + demographicswindow_main_table_header_t::consciousness_column_width);
	if(col_um_consciousness && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::consciousness_column_start), float(y), float(demographicswindow_main_table_header_t::consciousness_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_employment = rel_mouse_x >= demographicswindow_main_table_header_t::employment_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::employment_column_start + demographicswindow_main_table_header_t::employment_column_width);
	if(col_um_employment && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::employment_column_start), float(y), float(demographicswindow_main_table_header_t::employment_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_literacy = rel_mouse_x >= demographicswindow_main_table_header_t::literacy_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::literacy_column_start + demographicswindow_main_table_header_t::literacy_column_width);
	if(col_um_literacy && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::literacy_column_start), float(y), float(demographicswindow_main_table_header_t::literacy_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_money = rel_mouse_x >= demographicswindow_main_table_header_t::money_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::money_column_start + demographicswindow_main_table_header_t::money_column_width);
	if(col_um_money && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::money_column_start), float(y), float(demographicswindow_main_table_header_t::money_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_needs = rel_mouse_x >= demographicswindow_main_table_header_t::needs_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::needs_column_start + demographicswindow_main_table_header_t::needs_column_width);
	if(col_um_needs && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::needs_column_start), float(y), float(demographicswindow_main_table_header_t::needs_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
	bool col_um_rebels = rel_mouse_x >= demographicswindow_main_table_header_t::rebels_column_start && rel_mouse_x < (demographicswindow_main_table_header_t::rebels_column_start + demographicswindow_main_table_header_t::rebels_column_width);
	if(col_um_rebels && !under_mouse) {
		ogl::render_alpha_colored_rect(state, float(x + demographicswindow_main_table_header_t::rebels_column_start), float(y), float(demographicswindow_main_table_header_t::rebels_column_width), float(base_data.size.y), demographicswindow_main_table_t::table_highlight_color.r, demographicswindow_main_table_t::table_highlight_color.g, demographicswindow_main_table_t::table_highlight_color.b, demographicswindow_main_table_t::table_highlight_color.a);
	}
}
void demographicswindow_pop_row_t::on_update(sys::state& state) noexcept {
// BEGIN pop_row::update
// END
}
void demographicswindow_pop_row_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::pop_row"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	texture_key = win_data.texture;
	alt_texture_key = win_data.alt_texture;
	auto name_key = state.lookup_key("demographicswindow::pop_row");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "location") {
			auto cptr = std::make_unique<demographicswindow_pop_row_location_t>();
			cptr->parent = this;
			location = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size") {
			auto cptr = std::make_unique<demographicswindow_pop_row_size_t>();
			cptr->parent = this;
			size = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "size_trend") {
			auto cptr = std::make_unique<demographicswindow_pop_row_size_trend_t>();
			cptr->parent = this;
			size_trend = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture") {
			auto cptr = std::make_unique<demographicswindow_pop_row_culture_t>();
			cptr->parent = this;
			culture = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->color = child_data.table_highlight_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job") {
			auto cptr = std::make_unique<demographicswindow_pop_row_job_t>();
			cptr->parent = this;
			job = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion") {
			auto cptr = std::make_unique<demographicswindow_pop_row_religion_t>();
			cptr->parent = this;
			religion = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "ideology") {
			auto cptr = std::make_unique<demographicswindow_pop_row_ideology_t>();
			cptr->parent = this;
			ideology = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "issues") {
			auto cptr = std::make_unique<demographicswindow_pop_row_issues_t>();
			cptr->parent = this;
			issues = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "militancy") {
			auto cptr = std::make_unique<demographicswindow_pop_row_militancy_t>();
			cptr->parent = this;
			militancy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "consciousness") {
			auto cptr = std::make_unique<demographicswindow_pop_row_consciousness_t>();
			cptr->parent = this;
			consciousness = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "employment") {
			auto cptr = std::make_unique<demographicswindow_pop_row_employment_t>();
			cptr->parent = this;
			employment = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "literacy") {
			auto cptr = std::make_unique<demographicswindow_pop_row_literacy_t>();
			cptr->parent = this;
			literacy = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "money") {
			auto cptr = std::make_unique<demographicswindow_pop_row_money_t>();
			cptr->parent = this;
			money = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "needs") {
			auto cptr = std::make_unique<demographicswindow_pop_row_needs_t>();
			cptr->parent = this;
			needs = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "rebel_flag") {
			auto cptr = std::make_unique<demographicswindow_pop_row_rebel_flag_t>();
			cptr->parent = this;
			rebel_flag = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_name") {
			auto cptr = std::make_unique<demographicswindow_pop_row_culture_name_t>();
			cptr->parent = this;
			culture_name = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job_name") {
			auto cptr = std::make_unique<demographicswindow_pop_row_job_name_t>();
			cptr->parent = this;
			job_name = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_name") {
			auto cptr = std::make_unique<demographicswindow_pop_row_religion_name_t>();
			cptr->parent = this;
			religion_name = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "frames") {
			auto cptr = std::make_unique<demographicswindow_pop_row_frames_t>();
			cptr->parent = this;
			frames = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "movement_political") {
			auto cptr = std::make_unique<demographicswindow_pop_row_movement_political_t>();
			cptr->parent = this;
			movement_political = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "movement_social") {
			auto cptr = std::make_unique<demographicswindow_pop_row_movement_social_t>();
			cptr->parent = this;
			movement_social = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "details_button") {
			auto cptr = std::make_unique<demographicswindow_pop_row_details_button_t>();
			cptr->parent = this;
			details_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->tooltip_key = state.lookup_key(child_data.tooltip_text_key);
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN pop_row::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_pop_row(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_pop_row_t>();
	ptr->on_create(state);
	return ptr;
}
ui::message_result demographicswindow_filters_window_job_all_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::job_all::lbutton_action
	popwindow::excluded_types.clear();
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_job_all_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_job_all_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_job_all_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_job_all_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_job_all_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::job_all::update
	is_active = popwindow::excluded_types.empty();
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_job_all_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::job_all::create
// END
}
ui::message_result demographicswindow_filters_window_job_none_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::job_none::lbutton_action
	for(auto j : state.world.in_pop_type) {
		popwindow::excluded_types.insert(j.id.index());
	}
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_job_none_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_job_none_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_job_none_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_job_none_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_job_none_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::job_none::update
	is_active = (popwindow::excluded_types.size() == state.world.pop_type_size());
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_job_none_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::job_none::create
// END
}
ui::message_result demographicswindow_filters_window_culture_all_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::culture_all::lbutton_action
	popwindow::excluded_cultures.clear();
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_culture_all_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_culture_all_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_culture_all_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_culture_all_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_culture_all_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::culture_all::update
	is_active = popwindow::excluded_cultures.empty();
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_culture_all_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::culture_all::create
// END
}
ui::message_result demographicswindow_filters_window_culture_none_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::culture_none::lbutton_action
	for(auto c : state.world.in_culture) {
		popwindow::excluded_cultures.insert(c.id.index());
	}
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_culture_none_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_culture_none_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_culture_none_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_culture_none_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_culture_none_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::culture_none::update
	is_active = popwindow::excluded_cultures.size() == state.world.culture_size();
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_culture_none_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::culture_none::create
// END
}
ui::message_result demographicswindow_filters_window_religion_all_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::religion_all::lbutton_action
	popwindow::excluded_religions.clear();
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_religion_all_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_religion_all_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_religion_all_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_religion_all_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_religion_all_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::religion_all::update
	is_active = popwindow::excluded_religions.empty();
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_religion_all_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::religion_all::create
// END
}
ui::message_result demographicswindow_filters_window_religion_none_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::religion_none::lbutton_action
	for(auto r : state.world.in_religion)
		popwindow::excluded_religions.insert(r.id.index());
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_religion_none_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_religion_none_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_religion_none_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_religion_none_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_religion_none_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::religion_none::update
	is_active = popwindow::excluded_religions.size() == state.world.religion_size();
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_religion_none_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::religion_none::create
// END
}
ui::message_result demographicswindow_filters_window_location_all_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::location_all::lbutton_action
	popwindow::excluded_states.clear();
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_location_all_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_location_all_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_location_all_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_location_all_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_location_all_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::location_all::update
	is_active = popwindow::excluded_states.empty();
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_location_all_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::location_all::create
// END
}
ui::message_result demographicswindow_filters_window_location_none_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::location_none::lbutton_action
	for(auto s : state.world.nation_get_state_ownership(state.local_player_nation)) {
		popwindow::excluded_states.insert(s.get_state().id.index());
	}
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_location_none_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_location_none_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_location_none_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_location_none_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_location_none_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::location_none::update
	auto orange = state.world.nation_get_state_ownership(state.local_player_nation);
	is_active = popwindow::excluded_states.size() == size_t(orange.end() - orange.begin());
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_location_none_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::location_none::create
// END
}
ui::message_result demographicswindow_filters_window_non_colonial_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::non_colonial::lbutton_action
	popwindow::show_non_colonial = !popwindow::show_non_colonial;
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_non_colonial_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_non_colonial_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_non_colonial_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_non_colonial_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_non_colonial_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::non_colonial::update
	is_active = popwindow::show_non_colonial;
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_non_colonial_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::non_colonial::create
// END
}
ui::message_result demographicswindow_filters_window_colonial_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::colonial::lbutton_action
	popwindow::show_colonial = !popwindow::show_colonial;
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_colonial_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_colonial_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_colonial_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_colonial_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, true); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_colonial_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::colonial::update
	is_active = popwindow::show_colonial;
	text_color = is_active ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_filters_window_colonial_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::colonial::create
// END
}
int32_t demographicswindow_filters_window_job_list_t::max_page(){
	if(values.size() == 0) return 0;
	if(visible_items.size() == 0) return 0;
	return int32_t(values.size() - 1) / int32_t(visible_items.size());
}
void demographicswindow_filters_window_job_list_t::change_page(sys::state & state, int32_t new_page) {
	bool lflip = new_page < page && page > 0;
	bool rflip = new_page > page && page < max_page();
	if(rflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left, 200); 
	} else if(lflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left_rev, 200);
	}
	page = std::clamp(new_page, 0, max_page());
	state.game_state_updated.store(true, std::memory_order::release);
	if(rflip || lflip) {
		impl_on_update(state);
		state.ui_animation.post_update_frame(state);
	}
}
ui::message_result demographicswindow_filters_window_job_list_t::on_scroll(sys::state& state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept {
	change_page(state, page + ((amount < 0) ? 1 : -1));
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_job_list_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::job_list::update
// END
	page = std::clamp(page, 0, max_page());
	auto fill_count = visible_items.size();
	auto fill_start = size_t(page) * fill_count;
	for(size_t fill_position = 0; fill_position < fill_count; ++fill_position) {
		if(fill_position + fill_start < values.size()) {
			((demographicswindow_job_filter_t*)visible_items[fill_position])->value = values[fill_position + fill_start];
			visible_items[fill_position]->flags &= ~ui::element_base::is_invisible_mask;
		} else {
			visible_items[fill_position]->set_visible(state, false);
		}
	}
}
void demographicswindow_filters_window_job_list_t::on_create(sys::state& state) noexcept {
	auto ptr = make_demographicswindow_job_filter(state);
	int32_t item_y_size = ptr->base_data.size.y;
	visible_items.push_back(ptr.get());
	add_child_to_back(std::move(ptr));
	auto total_rows = int32_t(base_data.size.y) / item_y_size;
	for(int32_t i = 1; i < total_rows; ++i) {
		auto ptrb = make_demographicswindow_job_filter(state);
		ptrb->base_data.position.y = int16_t(i * item_y_size);
		visible_items.push_back(ptrb.get());
		add_child_to_back(std::move(ptrb));
	}
// BEGIN filters_window::job_list::create
	for(auto j : state.world.in_pop_type)
		values.push_back(j.id);
	std::sort(values.begin(), values.end(), [&](auto a, auto b) {
		return text::produce_simple_string(state, state.world.pop_type_get_name(a)) < text::produce_simple_string(state, state.world.pop_type_get_name(b));
	});
// END
}
int32_t demographicswindow_filters_window_culture_list_t::max_page(){
	if(values.size() == 0) return 0;
	if(visible_items.size() == 0) return 0;
	return int32_t(values.size() - 1) / int32_t(visible_items.size());
}
void demographicswindow_filters_window_culture_list_t::change_page(sys::state & state, int32_t new_page) {
	bool lflip = new_page < page && page > 0;
	bool rflip = new_page > page && page < max_page();
	if(rflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left, 200); 
	} else if(lflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left_rev, 200);
	}
	page = std::clamp(new_page, 0, max_page());
	state.game_state_updated.store(true, std::memory_order::release);
	if(rflip || lflip) {
		impl_on_update(state);
		state.ui_animation.post_update_frame(state);
	}
}
ui::message_result demographicswindow_filters_window_culture_list_t::on_scroll(sys::state& state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept {
	change_page(state, page + ((amount < 0) ? 1 : -1));
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_culture_list_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::culture_list::update
// END
	page = std::clamp(page, 0, max_page());
	auto fill_count = visible_items.size();
	auto fill_start = size_t(page) * fill_count;
	for(size_t fill_position = 0; fill_position < fill_count; ++fill_position) {
		if(fill_position + fill_start < values.size()) {
			((demographicswindow_culture_filter_t*)visible_items[fill_position])->value = values[fill_position + fill_start];
			visible_items[fill_position]->flags &= ~ui::element_base::is_invisible_mask;
		} else {
			visible_items[fill_position]->set_visible(state, false);
		}
	}
}
void demographicswindow_filters_window_culture_list_t::on_create(sys::state& state) noexcept {
	auto ptr = make_demographicswindow_culture_filter(state);
	int32_t item_y_size = ptr->base_data.size.y;
	visible_items.push_back(ptr.get());
	add_child_to_back(std::move(ptr));
	auto total_rows = int32_t(base_data.size.y) / item_y_size;
	for(int32_t i = 1; i < total_rows; ++i) {
		auto ptrb = make_demographicswindow_culture_filter(state);
		ptrb->base_data.position.y = int16_t(i * item_y_size);
		visible_items.push_back(ptrb.get());
		add_child_to_back(std::move(ptrb));
	}
// BEGIN filters_window::culture_list::create
	for(auto c : state.world.in_culture) {
		values.push_back(c.id);
	}
	std::sort(values.begin(), values.end(), [&](auto a, auto b) {
		return text::produce_simple_string(state, state.world.culture_get_name(a)) < text::produce_simple_string(state, state.world.culture_get_name(b));
	});
// END
}
int32_t demographicswindow_filters_window_religion_list_t::max_page(){
	if(values.size() == 0) return 0;
	if(visible_items.size() == 0) return 0;
	return int32_t(values.size() - 1) / int32_t(visible_items.size());
}
void demographicswindow_filters_window_religion_list_t::change_page(sys::state & state, int32_t new_page) {
	bool lflip = new_page < page && page > 0;
	bool rflip = new_page > page && page < max_page();
	if(rflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left, 200); 
	} else if(lflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left_rev, 200);
	}
	page = std::clamp(new_page, 0, max_page());
	state.game_state_updated.store(true, std::memory_order::release);
	if(rflip || lflip) {
		impl_on_update(state);
		state.ui_animation.post_update_frame(state);
	}
}
ui::message_result demographicswindow_filters_window_religion_list_t::on_scroll(sys::state& state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept {
	change_page(state, page + ((amount < 0) ? 1 : -1));
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_religion_list_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::religion_list::update
// END
	page = std::clamp(page, 0, max_page());
	auto fill_count = visible_items.size();
	auto fill_start = size_t(page) * fill_count;
	for(size_t fill_position = 0; fill_position < fill_count; ++fill_position) {
		if(fill_position + fill_start < values.size()) {
			((demographicswindow_religion_filter_t*)visible_items[fill_position])->value = values[fill_position + fill_start];
			visible_items[fill_position]->flags &= ~ui::element_base::is_invisible_mask;
		} else {
			visible_items[fill_position]->set_visible(state, false);
		}
	}
}
void demographicswindow_filters_window_religion_list_t::on_create(sys::state& state) noexcept {
	auto ptr = make_demographicswindow_religion_filter(state);
	int32_t item_y_size = ptr->base_data.size.y;
	visible_items.push_back(ptr.get());
	add_child_to_back(std::move(ptr));
	auto total_rows = int32_t(base_data.size.y) / item_y_size;
	for(int32_t i = 1; i < total_rows; ++i) {
		auto ptrb = make_demographicswindow_religion_filter(state);
		ptrb->base_data.position.y = int16_t(i * item_y_size);
		visible_items.push_back(ptrb.get());
		add_child_to_back(std::move(ptrb));
	}
// BEGIN filters_window::religion_list::create
	for(auto r : state.world.in_religion)
		values.push_back(r.id);
	std::sort(values.begin(), values.end(), [&](auto a, auto b) {
		return text::produce_simple_string(state, state.world.religion_get_name(a)) < text::produce_simple_string(state, state.world.religion_get_name(b));
	});
// END
}
int32_t demographicswindow_filters_window_location_list_t::max_page(){
	if(values.size() == 0) return 0;
	if(visible_items.size() == 0) return 0;
	return int32_t(values.size() - 1) / int32_t(visible_items.size());
}
void demographicswindow_filters_window_location_list_t::change_page(sys::state & state, int32_t new_page) {
	bool lflip = new_page < page && page > 0;
	bool rflip = new_page > page && page < max_page();
	if(rflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left, 200); 
	} else if(lflip) {
		auto pos = ui::get_absolute_location(state, *this);
		state.ui_animation.start_animation(state, pos.x, pos.y, base_data.size.x, base_data.size.y, ogl::animation::type::page_flip_left_rev, 200);
	}
	page = std::clamp(new_page, 0, max_page());
	state.game_state_updated.store(true, std::memory_order::release);
	if(rflip || lflip) {
		impl_on_update(state);
		state.ui_animation.post_update_frame(state);
	}
}
ui::message_result demographicswindow_filters_window_location_list_t::on_scroll(sys::state& state, int32_t x, int32_t y, float amount, sys::key_modifiers mods) noexcept {
	change_page(state, page + ((amount < 0) ? 1 : -1));
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_location_list_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::location_list::update
	values.clear();
	for(auto s : state.world.nation_get_state_ownership(state.local_player_nation)) {
		values.push_back(s.get_state().id);
	}
	sys::merge_sort(values.begin(), values.end(), [&](auto a, auto b) {
		return text::get_short_state_name(state, a) < text::get_short_state_name(state, b);
	});
// END
	page = std::clamp(page, 0, max_page());
	auto fill_count = visible_items.size();
	auto fill_start = size_t(page) * fill_count;
	for(size_t fill_position = 0; fill_position < fill_count; ++fill_position) {
		if(fill_position + fill_start < values.size()) {
			((demographicswindow_location_filter_t*)visible_items[fill_position])->value = values[fill_position + fill_start];
			visible_items[fill_position]->flags &= ~ui::element_base::is_invisible_mask;
		} else {
			visible_items[fill_position]->set_visible(state, false);
		}
	}
}
void demographicswindow_filters_window_location_list_t::on_create(sys::state& state) noexcept {
	auto ptr = make_demographicswindow_location_filter(state);
	int32_t item_y_size = ptr->base_data.size.y;
	visible_items.push_back(ptr.get());
	add_child_to_back(std::move(ptr));
	auto total_rows = int32_t(base_data.size.y) / item_y_size;
	for(int32_t i = 1; i < total_rows; ++i) {
		auto ptrb = make_demographicswindow_location_filter(state);
		ptrb->base_data.position.y = int16_t(i * item_y_size);
		visible_items.push_back(ptrb.get());
		add_child_to_back(std::move(ptrb));
	}
// BEGIN filters_window::location_list::create
// END
}
ui::message_result demographicswindow_filters_window_close_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::close_button::lbutton_action
	filters_window.set_visible(state, false);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_close_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_close_button_t::on_key_down(sys::state& state, sys::virtual_key key, sys::key_modifiers mods) noexcept {
	if(key == sys::virtual_key::ESCAPE) {
		on_lbutton_down(state, 0, 0, mods);
		return ui::message_result::consumed;
	}
	return ui::message_result::unseen;
}
void demographicswindow_filters_window_close_button_t::update_tooltip(sys::state& state, int32_t x, int32_t y, text::columnar_layout& contents) noexcept {
	text::add_line(state, contents, tooltip_key);
}
void demographicswindow_filters_window_close_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_close_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::close_button::update
// END
}
void demographicswindow_filters_window_close_button_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::close_button::create
// END
}
ui::message_result demographicswindow_filters_window_job_left_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::job_left::lbutton_action
	filters_window.job_list->change_page(state, filters_window.job_list->page - 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_job_left_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_job_left_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_job_left_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::job_left::update
// END
}
void demographicswindow_filters_window_job_left_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::job_left::create
// END
}
ui::message_result demographicswindow_filters_window_culture_left_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::culture_left::lbutton_action
	filters_window.culture_list->change_page(state, filters_window.culture_list->page - 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_culture_left_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_culture_left_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_culture_left_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::culture_left::update
// END
}
void demographicswindow_filters_window_culture_left_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::culture_left::create
// END
}
ui::message_result demographicswindow_filters_window_religion_left_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::religion_left::lbutton_action
	filters_window.religion_list->change_page(state, filters_window.religion_list->page - 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_religion_left_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_religion_left_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_religion_left_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::religion_left::update
// END
}
void demographicswindow_filters_window_religion_left_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::religion_left::create
// END
}
ui::message_result demographicswindow_filters_window_location_left_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::location_left::lbutton_action
	filters_window.location_list->change_page(state, filters_window.location_list->page - 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_location_left_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_location_left_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_location_left_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::location_left::update
// END
}
void demographicswindow_filters_window_location_left_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::location_left::create
// END
}
ui::message_result demographicswindow_filters_window_job_right_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::job_right::lbutton_action
	filters_window.job_list->change_page(state, filters_window.job_list->page + 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_job_right_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_job_right_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_job_right_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::job_right::update
// END
}
void demographicswindow_filters_window_job_right_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::job_right::create
// END
}
ui::message_result demographicswindow_filters_window_culture_right_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::culture_right::lbutton_action
	filters_window.culture_list->change_page(state, filters_window.culture_list->page + 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_culture_right_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_culture_right_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_culture_right_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::culture_right::update
// END
}
void demographicswindow_filters_window_culture_right_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::culture_right::create
// END
}
ui::message_result demographicswindow_filters_window_religion_right_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::religion_right::lbutton_action
	filters_window.religion_list->change_page(state, filters_window.religion_list->page + 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_religion_right_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_religion_right_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_religion_right_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::religion_right::update
// END
}
void demographicswindow_filters_window_religion_right_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::religion_right::create
// END
}
ui::message_result demographicswindow_filters_window_location_right_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN filters_window::location_right::lbutton_action
	filters_window.location_list->change_page(state, filters_window.location_list->page + 1);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_location_right_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_location_right_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_filters_window_location_right_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::location_right::update
// END
}
void demographicswindow_filters_window_location_right_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::location_right::create
// END
}
void demographicswindow_filters_window_job_page_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_job_page_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_filters_window_job_page_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_job_page_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::job_page::update
	if(filters_window.job_list->values.size() > filters_window.job_list->visible_items.size()) {
		set_text(state, std::to_string(filters_window.job_list->page + 1) + "/" + std::to_string(1 + filters_window.job_list->max_page()));
	} else {
		set_text(state, "");
	}
// END
}
void demographicswindow_filters_window_job_page_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::job_page::create
// END
}
void demographicswindow_filters_window_culture_page_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_culture_page_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_filters_window_culture_page_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_culture_page_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::culture_page::update
	if(filters_window.culture_list->values.size() > filters_window.culture_list->visible_items.size()) {
		set_text(state, std::to_string(filters_window.culture_list->page + 1) + "/" + std::to_string(1 + filters_window.culture_list->max_page()));
	} else {
		set_text(state, "");
	}
// END
}
void demographicswindow_filters_window_culture_page_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::culture_page::create
// END
}
void demographicswindow_filters_window_religion_page_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_religion_page_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_filters_window_religion_page_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_religion_page_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::religion_page::update
	if(filters_window.religion_list->values.size() > filters_window.religion_list->visible_items.size()) {
		set_text(state, std::to_string(filters_window.religion_list->page + 1) + "/" + std::to_string(1 + filters_window.religion_list->max_page()));
	} else {
		set_text(state, "");
	}
// END
}
void demographicswindow_filters_window_religion_page_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::religion_page::create
// END
}
void demographicswindow_filters_window_location_page_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_location_page_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_filters_window_location_page_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_location_page_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::location_page::update
	if(filters_window.location_list->values.size() > filters_window.location_list->visible_items.size()) {
		set_text(state, std::to_string(filters_window.location_list->page + 1) + "/" + std::to_string(1 + filters_window.location_list->max_page()));
	} else {
		set_text(state, "");
	}
// END
}
void demographicswindow_filters_window_location_page_t::on_create(sys::state& state) noexcept {
// BEGIN filters_window::location_page::create
// END
}
void demographicswindow_filters_window_job_header_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_job_header_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_job_header_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_job_header_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::job_header::update
// END
}
void demographicswindow_filters_window_job_header_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::job_header::create
// END
}
void demographicswindow_filters_window_culture_header_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_culture_header_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_culture_header_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_culture_header_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::culture_header::update
// END
}
void demographicswindow_filters_window_culture_header_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::culture_header::create
// END
}
void demographicswindow_filters_window_religion_header_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_religion_header_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_religion_header_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_religion_header_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::religion_header::update
// END
}
void demographicswindow_filters_window_religion_header_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::religion_header::create
// END
}
void demographicswindow_filters_window_location_header_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_filters_window_location_header_t::on_reset_text(sys::state& state) noexcept {
	cached_text = text::produce_simple_string(state, text_key);
	internal_layout.contents.clear();
	internal_layout.number_of_lines = 0;
	text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
	sl.add_text(state, cached_text);
}
void demographicswindow_filters_window_location_header_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_filters_window_location_header_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent)); 
// BEGIN filters_window::location_header::update
// END
}
void demographicswindow_filters_window_location_header_t::on_create(sys::state& state) noexcept {
	on_reset_text(state);
// BEGIN filters_window::location_header::create
// END
}
ui::message_result demographicswindow_filters_window_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	state.ui_state.drag_target = this;
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_filters_window_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_filters_window_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
}
void demographicswindow_filters_window_t::on_update(sys::state& state) noexcept {
// BEGIN filters_window::update
// END
}
void demographicswindow_filters_window_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::filters_window"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	texture_key = win_data.texture;
	auto name_key = state.lookup_key("demographicswindow::filters_window");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "job_all") {
			auto cptr = std::make_unique<demographicswindow_filters_window_job_all_t>();
			cptr->parent = this;
			job_all = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job_none") {
			auto cptr = std::make_unique<demographicswindow_filters_window_job_none_t>();
			cptr->parent = this;
			job_none = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_all") {
			auto cptr = std::make_unique<demographicswindow_filters_window_culture_all_t>();
			cptr->parent = this;
			culture_all = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_none") {
			auto cptr = std::make_unique<demographicswindow_filters_window_culture_none_t>();
			cptr->parent = this;
			culture_none = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_all") {
			auto cptr = std::make_unique<demographicswindow_filters_window_religion_all_t>();
			cptr->parent = this;
			religion_all = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_none") {
			auto cptr = std::make_unique<demographicswindow_filters_window_religion_none_t>();
			cptr->parent = this;
			religion_none = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location_all") {
			auto cptr = std::make_unique<demographicswindow_filters_window_location_all_t>();
			cptr->parent = this;
			location_all = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location_none") {
			auto cptr = std::make_unique<demographicswindow_filters_window_location_none_t>();
			cptr->parent = this;
			location_none = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "non_colonial") {
			auto cptr = std::make_unique<demographicswindow_filters_window_non_colonial_t>();
			cptr->parent = this;
			non_colonial = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "colonial") {
			auto cptr = std::make_unique<demographicswindow_filters_window_colonial_t>();
			cptr->parent = this;
			colonial = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job_list") {
			auto cptr = std::make_unique<demographicswindow_filters_window_job_list_t>();
			cptr->parent = this;
			job_list = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_list") {
			auto cptr = std::make_unique<demographicswindow_filters_window_culture_list_t>();
			cptr->parent = this;
			culture_list = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_list") {
			auto cptr = std::make_unique<demographicswindow_filters_window_religion_list_t>();
			cptr->parent = this;
			religion_list = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location_list") {
			auto cptr = std::make_unique<demographicswindow_filters_window_location_list_t>();
			cptr->parent = this;
			location_list = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "close_button") {
			auto cptr = std::make_unique<demographicswindow_filters_window_close_button_t>();
			cptr->parent = this;
			close_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->tooltip_key = state.lookup_key(child_data.tooltip_text_key);
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job_left") {
			auto cptr = std::make_unique<demographicswindow_filters_window_job_left_t>();
			cptr->parent = this;
			job_left = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_left") {
			auto cptr = std::make_unique<demographicswindow_filters_window_culture_left_t>();
			cptr->parent = this;
			culture_left = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_left") {
			auto cptr = std::make_unique<demographicswindow_filters_window_religion_left_t>();
			cptr->parent = this;
			religion_left = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location_left") {
			auto cptr = std::make_unique<demographicswindow_filters_window_location_left_t>();
			cptr->parent = this;
			location_left = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job_right") {
			auto cptr = std::make_unique<demographicswindow_filters_window_job_right_t>();
			cptr->parent = this;
			job_right = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_right") {
			auto cptr = std::make_unique<demographicswindow_filters_window_culture_right_t>();
			cptr->parent = this;
			culture_right = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_right") {
			auto cptr = std::make_unique<demographicswindow_filters_window_religion_right_t>();
			cptr->parent = this;
			religion_right = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location_right") {
			auto cptr = std::make_unique<demographicswindow_filters_window_location_right_t>();
			cptr->parent = this;
			location_right = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->flags |= ui::element_base::wants_update_when_hidden_mask;
			cptr->texture_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job_page") {
			auto cptr = std::make_unique<demographicswindow_filters_window_job_page_t>();
			cptr->parent = this;
			job_page = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_page") {
			auto cptr = std::make_unique<demographicswindow_filters_window_culture_page_t>();
			cptr->parent = this;
			culture_page = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_page") {
			auto cptr = std::make_unique<demographicswindow_filters_window_religion_page_t>();
			cptr->parent = this;
			religion_page = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location_page") {
			auto cptr = std::make_unique<demographicswindow_filters_window_location_page_t>();
			cptr->parent = this;
			location_page = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "job_header") {
			auto cptr = std::make_unique<demographicswindow_filters_window_job_header_t>();
			cptr->parent = this;
			job_header = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "culture_header") {
			auto cptr = std::make_unique<demographicswindow_filters_window_culture_header_t>();
			cptr->parent = this;
			culture_header = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "religion_header") {
			auto cptr = std::make_unique<demographicswindow_filters_window_religion_header_t>();
			cptr->parent = this;
			religion_header = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "location_header") {
			auto cptr = std::make_unique<demographicswindow_filters_window_location_header_t>();
			cptr->parent = this;
			location_header = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_key = state.lookup_key(child_data.text_key);
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN filters_window::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_filters_window(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_filters_window_t>();
	ptr->on_create(state);
	return ptr;
}
ui::message_result demographicswindow_job_filter_filter_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_job_filter_t& job_filter = *((demographicswindow_job_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN job_filter::filter_button::lbutton_action
	if(popwindow::excluded_types.contains(job_filter.value.index()))
		popwindow::excluded_types.erase(job_filter.value.index());
	else
		popwindow::excluded_types.insert(job_filter.value.index());
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_job_filter_filter_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_job_filter_filter_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_job_filter_filter_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_job_filter_t& job_filter = *((demographicswindow_job_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN job_filter::filter_button::update
	is_active = !popwindow::excluded_types.contains(job_filter.value.index());
// END
}
void demographicswindow_job_filter_filter_button_t::on_create(sys::state& state) noexcept {
// BEGIN job_filter::filter_button::create
// END
}
ui::message_result demographicswindow_job_filter_icon_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_job_filter_icon_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_job_filter_icon_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_job_filter_icon_t::on_update(sys::state& state) noexcept {
	demographicswindow_job_filter_t& job_filter = *((demographicswindow_job_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN job_filter::icon::update
	frame = int32_t(state.world.pop_type_get_sprite(job_filter.value)) - 1;
// END
}
void demographicswindow_job_filter_icon_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN job_filter::icon::create
// END
}
void demographicswindow_job_filter_filter_label_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_job_filter_filter_label_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_job_filter_filter_label_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_job_filter_filter_label_t::on_update(sys::state& state) noexcept {
	demographicswindow_job_filter_t& job_filter = *((demographicswindow_job_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN job_filter::filter_label::update
	set_text(state, text::produce_simple_string(state, state.world.pop_type_get_name(job_filter.value)));
	text_color = !popwindow::excluded_types.contains(job_filter.value.index()) ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_job_filter_filter_label_t::on_create(sys::state& state) noexcept {
// BEGIN job_filter::filter_label::create
// END
}
void demographicswindow_job_filter_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent)); 
// BEGIN job_filter::update
// END
}
void demographicswindow_job_filter_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::job_filter"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	auto name_key = state.lookup_key("demographicswindow::job_filter");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "filter_button") {
			auto cptr = std::make_unique<demographicswindow_job_filter_filter_button_t>();
			cptr->parent = this;
			filter_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "icon") {
			auto cptr = std::make_unique<demographicswindow_job_filter_icon_t>();
			cptr->parent = this;
			icon = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "filter_label") {
			auto cptr = std::make_unique<demographicswindow_job_filter_filter_label_t>();
			cptr->parent = this;
			filter_label = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN job_filter::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_job_filter(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_job_filter_t>();
	ptr->on_create(state);
	return ptr;
}
ui::message_result demographicswindow_religion_filter_filter_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_religion_filter_t& religion_filter = *((demographicswindow_religion_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN religion_filter::filter_button::lbutton_action
	if(popwindow::excluded_religions.contains(religion_filter.value.index()))
		popwindow::excluded_religions.erase(religion_filter.value.index());
	else
		popwindow::excluded_religions.insert(religion_filter.value.index());
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_religion_filter_filter_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_religion_filter_filter_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_religion_filter_filter_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_religion_filter_t& religion_filter = *((demographicswindow_religion_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN religion_filter::filter_button::update
	is_active = !popwindow::excluded_religions.contains(religion_filter.value.index());
// END
}
void demographicswindow_religion_filter_filter_button_t::on_create(sys::state& state) noexcept {
// BEGIN religion_filter::filter_button::create
// END
}
ui::message_result demographicswindow_religion_filter_icon_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
ui::message_result demographicswindow_religion_filter_icon_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::unseen;
}
void demographicswindow_religion_filter_icon_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(background_gid) {
		auto& gfx_def = state.ui_defs.gfx[background_gid];
		if(gfx_def.primary_texture_handle) {
			if(gfx_def.get_object_type() == ui::object_type::bordered_rect) {
				ogl::render_bordered_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), gfx_def.type_dependent, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else if(gfx_def.number_of_frames > 1) {
				ogl::render_subsprite(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), frame, gfx_def.number_of_frames, float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			} else {
				ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, false), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_texture_handle(state, gfx_def.primary_texture_handle, gfx_def.is_partially_transparent()), base_data.get_rotation(), gfx_def.is_vertically_flipped(), state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
			}
		}
	}
}
void demographicswindow_religion_filter_icon_t::on_update(sys::state& state) noexcept {
	demographicswindow_religion_filter_t& religion_filter = *((demographicswindow_religion_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN religion_filter::icon::update
	frame = int32_t(state.world.religion_get_icon(religion_filter.value)) - 1;
// END
}
void demographicswindow_religion_filter_icon_t::on_create(sys::state& state) noexcept {
	if(auto it = state.ui_state.gfx_by_name.find(state.lookup_key(gfx_key)); it != state.ui_state.gfx_by_name.end()) {
		background_gid = it->second;
	}
// BEGIN religion_filter::icon::create
// END
}
void demographicswindow_religion_filter_filter_label_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_religion_filter_filter_label_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_religion_filter_filter_label_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_religion_filter_filter_label_t::on_update(sys::state& state) noexcept {
	demographicswindow_religion_filter_t& religion_filter = *((demographicswindow_religion_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN religion_filter::filter_label::update
	set_text(state, text::produce_simple_string(state, state.world.religion_get_name(religion_filter.value)));
	text_color = !popwindow::excluded_religions.contains(religion_filter.value.index()) ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_religion_filter_filter_label_t::on_create(sys::state& state) noexcept {
// BEGIN religion_filter::filter_label::create
// END
}
void demographicswindow_religion_filter_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent)); 
// BEGIN religion_filter::update
// END
}
void demographicswindow_religion_filter_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::religion_filter"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	auto name_key = state.lookup_key("demographicswindow::religion_filter");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "filter_button") {
			auto cptr = std::make_unique<demographicswindow_religion_filter_filter_button_t>();
			cptr->parent = this;
			filter_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "icon") {
			auto cptr = std::make_unique<demographicswindow_religion_filter_icon_t>();
			cptr->parent = this;
			icon = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->gfx_key = child_data.texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "filter_label") {
			auto cptr = std::make_unique<demographicswindow_religion_filter_filter_label_t>();
			cptr->parent = this;
			filter_label = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN religion_filter::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_religion_filter(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_religion_filter_t>();
	ptr->on_create(state);
	return ptr;
}
ui::message_result demographicswindow_location_filter_filter_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_location_filter_t& location_filter = *((demographicswindow_location_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN location_filter::filter_button::lbutton_action
	if(popwindow::excluded_states.contains(location_filter.value.index()))
		popwindow::excluded_states.erase(location_filter.value.index());
	else
		popwindow::excluded_states.insert(location_filter.value.index());
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_location_filter_filter_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_location_filter_filter_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_location_filter_filter_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_location_filter_t& location_filter = *((demographicswindow_location_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN location_filter::filter_button::update
	is_active = !popwindow::excluded_states.contains(location_filter.value.index());
// END
}
void demographicswindow_location_filter_filter_button_t::on_create(sys::state& state) noexcept {
// BEGIN location_filter::filter_button::create
// END
}
void demographicswindow_location_filter_filter_label_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_location_filter_filter_label_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_location_filter_filter_label_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_location_filter_filter_label_t::on_update(sys::state& state) noexcept {
	demographicswindow_location_filter_t& location_filter = *((demographicswindow_location_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN location_filter::filter_label::update
	set_text(state, text::get_short_state_name(state, location_filter.value));
	text_color = !popwindow::excluded_states.contains(location_filter.value.index()) ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_location_filter_filter_label_t::on_create(sys::state& state) noexcept {
// BEGIN location_filter::filter_label::create
// END
}
void demographicswindow_location_filter_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent)); 
// BEGIN location_filter::update
// END
}
void demographicswindow_location_filter_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::location_filter"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	auto name_key = state.lookup_key("demographicswindow::location_filter");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "filter_button") {
			auto cptr = std::make_unique<demographicswindow_location_filter_filter_button_t>();
			cptr->parent = this;
			filter_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "filter_label") {
			auto cptr = std::make_unique<demographicswindow_location_filter_filter_label_t>();
			cptr->parent = this;
			filter_label = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN location_filter::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_location_filter(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_location_filter_t>();
	ptr->on_create(state);
	return ptr;
}
ui::message_result demographicswindow_culture_filter_filter_button_t::on_lbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	demographicswindow_culture_filter_t& culture_filter = *((demographicswindow_culture_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
	sound::play_interface_sound(state, sound::get_click_sound(state), state.user_settings.interface_volume* state.user_settings.master_volume);
// BEGIN culture_filter::filter_button::lbutton_action
	if(popwindow::excluded_cultures.contains(culture_filter.value.index()))
		popwindow::excluded_cultures.erase(culture_filter.value.index());
	else
		popwindow::excluded_cultures.insert(culture_filter.value.index());
	state.game_state_updated.store(true, std::memory_order::release);
// END
	return ui::message_result::consumed;
}
ui::message_result demographicswindow_culture_filter_filter_button_t::on_rbutton_down(sys::state& state, int32_t x, int32_t y, sys::key_modifiers mods) noexcept {
	return ui::message_result::consumed;
}
void demographicswindow_culture_filter_filter_button_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(is_active)
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, alt_background_texture, alt_texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale())); 
	else
		ogl::render_textured_rect(state, ui::get_color_modification(this == state.ui_state.under_mouse, false, true), float(x), float(y), float(base_data.size.x), float(base_data.size.y), ogl::get_late_load_texture_handle(state, background_texture, texture_key), base_data.get_rotation(), false, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()));
}
void demographicswindow_culture_filter_filter_button_t::on_update(sys::state& state) noexcept {
	demographicswindow_culture_filter_t& culture_filter = *((demographicswindow_culture_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN culture_filter::filter_button::update
	is_active = !popwindow::excluded_cultures.contains(culture_filter.value.index());
// END
}
void demographicswindow_culture_filter_filter_button_t::on_create(sys::state& state) noexcept {
// BEGIN culture_filter::filter_button::create
// END
}
void demographicswindow_culture_filter_filter_label_t::set_text(sys::state& state, std::string const& new_text) {
	if(new_text != cached_text) {
		cached_text = new_text;
		internal_layout.contents.clear();
		internal_layout.number_of_lines = 0;
		text::single_line_layout sl{ internal_layout, text::layout_parameters{ 0, 0, static_cast<int16_t>(base_data.size.x), static_cast<int16_t>(base_data.size.y), text::make_font_id(state, text_is_header, text_scale * 16), 0, text_alignment, text::text_color::black, true, true }, state.world.locale_get_native_rtl(state.font_collection.get_current_locale()) ? text::layout_base::rtl_status::rtl : text::layout_base::rtl_status::ltr };
		sl.add_text(state, cached_text);
	}
}
void demographicswindow_culture_filter_filter_label_t::on_reset_text(sys::state& state) noexcept {
}
void demographicswindow_culture_filter_filter_label_t::render(sys::state & state, int32_t x, int32_t y) noexcept {
	if(internal_layout.contents.empty()) return;
	auto fh = text::make_font_id(state, text_is_header, text_scale * 16);
	auto linesz = state.font_collection.line_height(state, fh); 
	if(linesz == 0.0f) return;
	auto ycentered = (base_data.size.y - linesz) / 2;
	auto cmod = ui::get_color_modification(this == state.ui_state.under_mouse, false, false); 
	for(auto& t : internal_layout.contents) {
		ui::render_text_chunk(state, t, float(x) + t.x, float(y + int32_t(ycentered)),  fh, ui::get_text_color(state, text_color), cmod);
	}
}
void demographicswindow_culture_filter_filter_label_t::on_update(sys::state& state) noexcept {
	demographicswindow_culture_filter_t& culture_filter = *((demographicswindow_culture_filter_t*)(parent)); 
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent->parent)); 
// BEGIN culture_filter::filter_label::update
	set_text(state, text::produce_simple_string(state, state.world.culture_get_name(culture_filter.value)));
	text_color = !popwindow::excluded_cultures.contains(culture_filter.value.index()) ? text::text_color::black : text::text_color::gold;
// END
}
void demographicswindow_culture_filter_filter_label_t::on_create(sys::state& state) noexcept {
// BEGIN culture_filter::filter_label::create
// END
}
void demographicswindow_culture_filter_t::on_update(sys::state& state) noexcept {
	demographicswindow_filters_window_t& filters_window = *((demographicswindow_filters_window_t*)(parent->parent)); 
// BEGIN culture_filter::update
// END
}
void demographicswindow_culture_filter_t::on_create(sys::state& state) noexcept {
	auto window_bytes = state.ui_state.new_ui_windows.find(std::string("demographicswindow::culture_filter"));
	if(window_bytes == state.ui_state.new_ui_windows.end()) std::abort();
	std::vector<sys::aui_pending_bytes> pending_children;
	auto win_data = read_window_bytes(window_bytes->second.data, window_bytes->second.size, pending_children);
	base_data.position.x = win_data.x_pos;
	base_data.position.y = win_data.y_pos;
	base_data.size.x = win_data.x_size;
	base_data.size.y = win_data.y_size;
	base_data.flags = uint8_t(win_data.orientation);
	auto name_key = state.lookup_key("demographicswindow::culture_filter");
	for(auto ex : state.ui_defs.extensions) {
		if(name_key && ex.window == name_key) {
			auto ch_res = ui::make_element_immediate(state, ex.child);
			if(ch_res) {
				this->add_child_to_back(std::move(ch_res));
			}
		}
	}
	while(!pending_children.empty()) {
		auto child_data = read_child_bytes(pending_children.back().data, pending_children.back().size);
		pending_children.pop_back();
		if(child_data.name == "filter_button") {
			auto cptr = std::make_unique<demographicswindow_culture_filter_filter_button_t>();
			cptr->parent = this;
			filter_button = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->texture_key = child_data.texture;
			cptr->alt_texture_key = child_data.alt_texture;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
		if(child_data.name == "filter_label") {
			auto cptr = std::make_unique<demographicswindow_culture_filter_filter_label_t>();
			cptr->parent = this;
			filter_label = cptr.get();
			cptr->base_data.position.x = child_data.x_pos;
			cptr->base_data.position.y = child_data.y_pos;
			cptr->base_data.size.x = child_data.x_size;
			cptr->base_data.size.y = child_data.y_size;
			cptr->text_scale = child_data.text_scale;
			cptr->text_is_header = (child_data.text_type == aui_text_type::header);
			cptr->text_alignment = child_data.text_alignment;
			cptr->text_color = child_data.text_color;
			cptr->on_create(state);
			this->add_child_to_back(std::move(cptr));
		continue;
		}
	}
// BEGIN culture_filter::create
// END
}
std::unique_ptr<ui::element_base> make_demographicswindow_culture_filter(sys::state& state) {
	auto ptr = std::make_unique<demographicswindow_culture_filter_t>();
	ptr->on_create(state);
	return ptr;
}
// LOST-CODE
}
